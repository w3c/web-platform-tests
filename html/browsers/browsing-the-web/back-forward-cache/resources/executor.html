<!DOCTYPE HTML>
<script src="/html/cross-origin-embedder-policy/credentialless/resources/dispatcher.js"></script>
<script>
const params = new URLSearchParams(window.location.search);
const uuid = params.get('uuid');

// --------
// Recording events

// The recorded events are stored in localStorage rather than global variables
// to catch events fired just before navigating out.
function getPushedItems(key) {
  return JSON.parse(localStorage.getItem(key) || '[]');
}

function pushItem(key, value) {
  const array = getPushedItems(key);
  array.push(value);
  localStorage.setItem(key, JSON.stringify(array));
}

function recordEvent(eventName) {
  pushItem(uuid + '.observedEvents', eventName);
}

function getRecordedEvents() {
  return getPushedItems(uuid + '.observedEvents');
}

// Records events fired on `window` and `document`, with names listed in
// `eventNames`.
function startRecordingEvents(eventNames) {
  for (const eventName of eventNames) {
    window.addEventListener(eventName, event => {
      let result = eventName;
      if (event.persisted) {
        result += '.persisted';
      }
      if (eventName === 'visibilitychange') {
        result += '.' + document.visibilityState;
      }
      recordEvent('window.' + result);
    });
    document.addEventListener(eventName, () => {
      let result = eventName;
      if (eventName === 'visibilitychange') {
        result += '.' + document.visibilityState;
      }
      recordEvent('document.' + result);
    });
  }
}

// When a comma-separated list of event names are given as the `events`
// parameter in the URL, start record the events of the given names.
if (params.get('events')) {
  startRecordingEvents(params.get('events').split(','));
}

// --------
// Executor and BFCache detection

// When navigating out from this page and then back navigating,
// call prepareNavigation() immediately before navigating out.
//
// In such scenarios, `assert_bfcached()` etc. in `helper.sub.js` can determine
// whether the page is restored from BFCache or not, by observing
// - isPageshowFired: whether the pageshow event listener added by the
//   prepareNavigation() before navigating out, and
// - loadCount: whether this inline script is evaluated again

// prepareNavigation() also suspends task polling, to avoid in-flight fetch
// requests during navigation that might evict the page from BFCache.
// Task polling is resumed later
// - (BFCache cases) when the pageshow event listener added by
//   prepareNavigation() is executed, or
// - (Non-BFCache cases) when executeOrders() is called again during
//   non-BFCache page loading.

window.isPageshowFired = false;

window.shouldSuspendFetch = false;

window.loadCount = parseInt(localStorage.getItem(uuid + '.loadCount') || '0') + 1;
localStorage.setItem(uuid + '.loadCount', loadCount);

function prepareNavigation() {
  window.shouldSuspendFetch = true;
  window.addEventListener(
    'pageshow',
    () => {
      window.isPageshowFired = true;
      window.shouldSuspendFetch = false;
    },
    {once: true});
}

// Tasks are executed after a pageshow event is fired.
window.addEventListener('pageshow', () => {
    const executeOrders = async function() {
      while (true) {
        if (!window.shouldSuspendFetch) {
          const task = await receive(uuid);
          await eval(`(async () => {${task}})()`);
        }
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    };
    executeOrders();
  },
  {once: true});
</script>
