<!DOCTYPE html>

<meta charset="utf-8">
<title>Receiving a message through PresentationConnection</title>
<link rel="author" title="Tomoyuki Shimizu" href="https://github.com/tomoyukilabs/">
<link rel="help" href="http://w3c.github.io/presentation-api/#receiving-a-message-through-presentationconnection">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="common.js"></script>
<script src="support/stash.js"></script>

<p id="notice">
  Click the button below and select the available presentation display, to start the manual test. The test passes if a "PASS" result appears.<br>
  <button id="presentBtn">Start Presentation Test</button>
</p>

<script>
    setup({explicit_timeout: true});

    const presentBtn = document.getElementById('presentBtn');

    presentBtn.onclick = () => {
        presentBtn.disabled = true;

        promise_test(t => {
            let connection, watcher, timeout, eventWatcher;
            const request = new PresentationRequest(presentationUrls);

            const checkEvent = event => {
                assert_true(event.isTrusted, 'a trusted event is fired');
                assert_true(event instanceof MessageEvent, 'The event uses the MessageEvent interface');
                assert_false(event.bubbles, 'the event does not bubble');
                assert_false(event.cancelable, 'the event is not cancelable');
            };

            t.add_cleanup(() => {
                if (connection) {
                    if (connection.state === 'connected')
                        connection.terminate();
                    else if (connection.state === 'closed') {
                        request.reconnect(connection.id).then(c => {
                            c.terminate();
                        });
                    }
                }
                const notice = document.getElementById('notice');
                notice.parentNode.removeChild(notice);
                stopWaitingStash();
            });

            return request.start().then(c => {
                return initStash().then(() => {
                    return uploadStash('onmessage');
                }).then(() => {
                    return c;
                });
            }).then(c => {
                connection = c;
                assert_equals(connection.state, 'connecting', 'the initial state of the presentation connection is "connecting"');
                assert_equals(connection.binaryType, 'arraybuffer', 'the default value of binaryType is "arraybuffer"');

                // enable timeout again, cause no user action is needed from here.
                t.step_timeout(() => {
                    t.force_timeout();
                    t.done();
                }, 5000);

                eventWatcher = new EventWatcher(t, connection, 'message');
                return eventWatcher.wait_for('message');
            }).then(event => {
                checkEvent(event);
                assert_equals(event.data, message1, 'receive a string correctly');
                return eventWatcher.wait_for('message');
            }).then(event => {
                checkEvent(event);
                assert_equals(event.data, message2, 'receive a string correctly');
                return eventWatcher.wait_for('message');
            }).then(event => {
                checkEvent(event);
                assert_true(event.data instanceof ArrayBuffer, 'receive binary data as ArrayBuffer');
                assert_true(event.data.equals(message3), 'receive an ArrayBuffer correctly (originally a Blob at a receiving user agent)');
                return eventWatcher.wait_for('message');
            }).then(event => {
                checkEvent(event);
                assert_true(event.data instanceof ArrayBuffer, 'receive binary data as ArrayBuffer');
                assert_true(event.data.equals(message4), 'receive an ArrayBuffer correctly (originally an ArrayBuffer at a receiving user agent)');
                return eventWatcher.wait_for('message');
            }).then(event => {
                checkEvent(event);
                assert_true(event.data instanceof ArrayBuffer, 'receive binary data as ArrayBuffer');
                assert_true(event.data.equals(message5), 'receive an ArrayBuffer correctly (originally an ArrayBufferView at a receiving user agent)');

                connection.binaryType = 'blob';
                return uploadStash('blob');
            }).then(() => {
                return eventWatcher.wait_for('message');
            }).then(event => {
                assert_true(event.data instanceof Blob, 'receive binary data as Blob');
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = resolve;
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(event.data);
                });
            }).then(event => {
                assert_true(event.target.result.equals(message5), 'receive a Blob correctly');
                connection.terminate();
            });
        });
    };
</script>
