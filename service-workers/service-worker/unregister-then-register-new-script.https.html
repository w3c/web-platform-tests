<!DOCTYPE html>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="resources/test-helpers.sub.js"></script>
<script>
var worker_url = 'resources/empty-worker.js';

async_test(function(t) {
    var scope = 'resources/scope/unregister-then-register-new-script-that-exists';
    var new_worker_url = worker_url + '?new';
    var iframe;
    var registration;
    var new_registration;

    service_worker_unregister_and_register(t, worker_url, scope)
      .then(function(r) {
          registration = r;
          return wait_for_state(t, r.installing, 'activated');
        })
      .then(function() {
          return with_iframe(scope);
        })
      .then(function(frame) {
          iframe = frame;
          return registration.unregister();
        })
      .then(function() {
          return navigator.serviceWorker.register(new_worker_url,
                                                  { scope: scope });
        })
      .then(function(r) {
          new_registration = r;
          assert_equals(registration.installing.scriptURL,
                        normalizeURL(new_worker_url),
                        'before activated registration.installing');
          assert_equals(registration.waiting, null,
                        'before activated registration.waiting');
          assert_equals(registration.active.scriptURL, normalizeURL(worker_url),
                        'before activated registration.active');
          assert_equals(new_registration.installing.scriptURL,
                        normalizeURL(new_worker_url),
                        'before activated new_registration.installing');
          assert_equals(new_registration.waiting, null,
                        'before activated new_registration.waiting');
          assert_equals(new_registration.active.scriptURL,
                        normalizeURL(worker_url),
                        'before activated new_registration.active');
          iframe.remove();
          return wait_for_state(t, registration.installing, 'activated');
        })
      .then(function() {
          assert_equals(new_registration.installing, null,
                        'after activated new_registration.installing');
          assert_equals(new_registration.waiting, null,
                        'after activated new_registration.waiting');
          assert_equals(new_registration.active.scriptURL,
                        normalizeURL(new_worker_url),
                        'after activated new_registration.active');
          return with_iframe(scope);
        })
      .then(function(frame) {
          assert_equals(
              frame.contentWindow.navigator.serviceWorker.controller.scriptURL,
              normalizeURL(new_worker_url),
              'the new worker should control a new document');
          frame.remove();
          return registration.unregister();
        })
      .then(function() {
          t.done();
        })
      .catch(unreached_rejection(t));
}, 'Registering a new script URL while an unregistered registration is in use');

promise_test(async function(t) {
  const scope = 'resources/scope/unregister-then-register-new-script-that-404s';
  const registration = await service_worker_unregister_and_register(t, worker_url, scope);
  await wait_for_state(t, registration.installing, 'activated');

  const iframe = await with_iframe(scope);

  await registration.unregister();

  try {
    await navigator.serviceWorker.register('this-will-404', { scope });
    assert_unreached('register should reject');
  } catch (err) {}

  assert_equals(registration.installing, null, 'registration.installing');
  assert_equals(registration.waiting, null, 'registration.waiting');
  assert_equals(registration.active.scriptURL, normalizeURL(worker_url), 'registration.active');

  const newIframe = await with_iframe(scope);

  assert_equals(newIframe.contentWindow.navigator.serviceWorker.controller, null, 'Document should not be controlled');
  newIframe.remove();
  iframe.remove();
}, 'Registering a new script URL that 404s does not resurrect unregistered registration');
// Service worker used to 'ressurect' registrations, so registration and new_registration would be equal.
// This has since been changed.

promise_test(async function(t) {
  const scope = 'resources/scope/unregister-then-register-new-script-that-404s';
  const registration = await service_worker_unregister_and_register(t, worker_url, scope);
  await wait_for_state(t, registration.installing, 'activated');

  const iframe = await with_iframe(scope);

  await registration.unregister();

  const newRegistration = await navigator.serviceWorker.register(
    'resources/reject-install-worker.js', { scope }
  );
  await wait_for_state(t, newRegistration.installing, 'redundant');

  assert_equals(registration.installing, null, 'registration.installing');
  assert_equals(registration.waiting, null, 'registration.waiting');
  assert_equals(registration.active.scriptURL, null, 'registration.active');
  assert_not_equals(registration, newRegistration, 'New registration is different');

  iframe.remove();
}, 'Registering a new script URL that fails to install does not resurrect unregistered registration');
// Service worker used to 'ressurect' registrations, so registration and new_registration would be equal.
// This has since been changed.
</script>
