<!doctype html>
<title>MediaStreamTrack applyConstraints</title>
<p class="instructions">When prompted, accept to share your video stream.</p>
<script src=/resources/testharness.js></script>
<script src=/resources/testharnessreport.js></script>
<script>
  'use strict'

  // https://w3c.github.io/mediacapture-main/#dom-mediastreamtrack-applyconstraints

  promise_test(async t => {
    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
    const [track] = stream.getVideoTracks();
    t.add_cleanup(() => track.stop());
    try {
      await track.applyConstraints({ groupId: { exact: "INVALID" } });
      t.unreached_func('Accepted invalid groupID')();
    } catch (e) {
      assert_equals(e.name, 'OverconstrainedError');
      assert_equals(e.constraint, 'groupId');
    }
  }, 'applyConstraints rejects invalid groupID');

  promise_test(async t => {
    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
    const [track] = stream.getVideoTracks();
    t.add_cleanup(() => track.stop());
    const groupId = track.getSettings().groupId;
    assert_not_equals(groupId, undefined);
    await track.applyConstraints({ groupId: "INVALID" });
    assert_equals(track.getSettings().groupId, groupId);
  }, 'applyConstraints accepts invalid ideal groupID, does not change setting');

  promise_test(async t => {
    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
    const [track] = stream.getVideoTracks();
    t.add_cleanup(() => track.stop());
    const settings = track.getSettings();
    const devices = await navigator.mediaDevices.enumerateDevices();
    const anotherDevice = devices.find((kind, groupId) => {
      return kind == "videoinput" && groupId != settings.groupId;
    });
    if (anotherDevice !== undefined) {
      try {
        await track.applyConstraints({ groupId: { exact: anotherDevice.groupId } });
        t.unreached_func('applyConstraints() must fail when attempt to switch device using groupId')();
      } catch (e) {
        assert_equals(e.name, 'OverconstrainedError');
        assert_equals(e.constraint, 'groupId');
      }
    }
  }, 'applyConstraints rejects attempt to switch device using groupId');

  promise_test(async t => {
    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
    const [track] = stream.getVideoTracks();
    t.add_cleanup(() => track.stop());
    try {
      await track.applyConstraints({ resizeMode: { exact: "INVALID" } });
      t.unreached_func('applyConstraints() must fail with invalid resizeMode')();
    } catch (e) {
      assert_equals(e.name, 'OverconstrainedError');
      assert_equals(e.constraint, 'resizeMode');
    }
  }, 'applyConstraints rejects invalid resizeMode');

  promise_test(async t => {
    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
    const [track] = stream.getVideoTracks();
    t.add_cleanup(() => track.stop());
    const resizeMode = track.getSettings().resizeMode;
    await track.applyConstraints({ resizeMode: "INVALID" });
    assert_equals(track.getSettings().resizeMode, resizeMode);
  }, 'applyConstraints accepts invalid ideal resizeMode, does not change setting');
</script>
