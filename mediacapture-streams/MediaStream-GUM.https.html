<!doctype html>
<meta charset="utf-8">
<title>MediaStream getUserMedia test</title>
<link rel="author" title="Intel" href="http://www.intel.com">
<link rel="help" href="https://w3c.github.io/mediacapture-main/#mediastream">
<script src=/resources/testharness.js></script>
<script src=/resources/testharnessreport.js></script>

<p class="instructions">Use a test device with camera(embedded or external).</p>
<p class="instructions">When prompted, accept to share camera.</p>

<script>

test(() => {
  assert_true(undefined !== navigator.mediaDevices && undefined !== navigator.mediaDevices.getUserMedia, "navigator.mediaDevices.getUserMedia exists");
}, "mediaDevices.getUserMedia() is present on navigator");

promise_test(t => {
  return promise_rejects(t, new TypeError(), navigator.mediaDevices.getUserMedia({}));
}, "Tests that getUserMedia is rejected with a TypeError when used with an empty options parameter");

promise_test(async t => {
  // Note - integer conversion is weird for +inf and numbers > 2^32, so we
  // use a number less than 2^32 for testing.
  try {
    const stream = await navigator.mediaDevices.getUserMedia({video: {width: {min:100000000}}});
    t.add_cleanup(() => stream.getVideoTracks()[0].stop());
    t.unreached_func("a Video stream of width 100M cannot be created")();
  } catch (e) {
    assert_equals(e.name, "OverconstrainedError", "An impossible constraint triggers a OverconstrainedError");
    assert_equals(e.constraint, "width", "The name of the unsatisfied constraint is given in error.constraint");
  };
}, "Tests that setting an impossible constraint in getUserMedia fails");

promise_test(async t => {
  const stream = await navigator.mediaDevices.getUserMedia({video: {advanced: [{width: {min:1024, max: 800}}]}});
  t.add_cleanup(() => stream.getVideoTracks()[0].stop());
  assert_equals(stream.getVideoTracks().length, 1, "the media stream has exactly one video track");
}, "Tests that setting an optional constraint in getUserMedia is handled as optional");

promise_test(async t => {
  const stream = await navigator.mediaDevices.getUserMedia({video: {width: {min:0}}});
  t.add_cleanup(() => stream.getVideoTracks()[0].stop());
  assert_equals(stream.getVideoTracks().length, 1, "the media stream has exactly one video track");
}, "Tests that setting a trivial mandatory constraint in getUserMedia works");

promise_test(t => {
  return promise_rejects(t, new TypeError(), navigator.mediaDevices.getUserMedia({doesnotexist: true}));
}, "Tests that getUserMedia is rejected with a TypeError when only used with an unknown device type");

promise_test(async t => {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({video: {facingMode: {exact: ''}}});
    t.add_cleanup(() => stream.getVideoTracks()[0].stop());
    t.unreached_func("The empty string is not a valid facingMode")();
  } catch (e) {
    assert_equals(e.name, "OverconstrainedError");
    assert_equals(e.constraint, "facingMode");
  };
}, "Tests that setting an invalid facingMode constraint in getUserMedia fails");

</script>
