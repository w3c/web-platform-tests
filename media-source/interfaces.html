<!doctype html>
<meta charset=utf-8>
<title>Media Source Extensions IDL tests</title>
<div id=log></div>
<script src=/resources/testharness.js></script>
<script src=/resources/testharnessreport.js></script>
<script src=/resources/webidl2/lib/webidl2.js></script>
<script src=/resources/idlharness.js></script>
<script type=text/plain class=untested>
interface EventTarget {
  void addEventListener(DOMString type, EventListener? callback, optional boolean capture /* = false */);
  void removeEventListener(DOMString type, EventListener? callback, optional boolean capture /* = false */);
  boolean dispatchEvent(Event event);
};
interface URL {};
interface HTMLVideoElement {};
interface AudioTrack {};
interface VideoTrack {};
interface TextTrack {};
interface TimeRanges {};
typedef double DOMHighResTimeStamp;
</script>
<script type=text/plain>
[Constructor]
interface MediaSource : EventTarget {
    readonly    attribute SourceBufferList    sourceBuffers;
    readonly    attribute SourceBufferList    activeSourceBuffers;
    readonly    attribute ReadyState          readyState;
                attribute unrestricted double duration;
    SourceBuffer   addSourceBuffer (DOMString type);
    void           removeSourceBuffer (SourceBuffer sourceBuffer);
    void           endOfStream (optional EndOfStreamError error);
    static boolean isTypeSupported (DOMString type);
};

interface SourceBuffer : EventTarget {
                attribute AppendMode          mode;
    readonly    attribute boolean             updating;
    readonly    attribute TimeRanges          buffered;
                attribute double              timestampOffset;
    readonly    attribute AudioTrackList      audioTracks;
    readonly    attribute VideoTrackList      videoTracks;
    readonly    attribute TextTrackList       textTracks;
                attribute double              appendWindowStart;
                attribute unrestricted double appendWindowEnd;
    void appendBuffer (ArrayBuffer data);
    void appendBuffer (ArrayBufferView data);
    void appendStream (Stream stream, [EnforceRange] optional unsigned long long maxSize);
    void abort ();
    void remove (double start, double end);
};

interface SourceBufferList : EventTarget {
    readonly    attribute unsigned long length;
    getter SourceBuffer (unsigned long index);
};

interface VideoPlaybackQuality {
    readonly    attribute DOMHighResTimeStamp creationTime;
    readonly    attribute unsigned long       totalVideoFrames;
    readonly    attribute unsigned long       droppedVideoFrames;
    readonly    attribute unsigned long       corruptedVideoFrames;
    readonly    attribute double              totalFrameDelay;
};

partial interface URL {
    static DOMString createObjectURL (MediaSource mediaSource);
};

partial interface HTMLVideoElement {
    VideoPlaybackQuality getVideoPlaybackQuality ();
};

partial interface AudioTrack {
                attribute DOMString     kind;
                attribute DOMString     language;
    readonly    attribute SourceBuffer? sourceBuffer;
};

partial interface VideoTrack {
                attribute DOMString     kind;
                attribute DOMString     language;
    readonly    attribute SourceBuffer? sourceBuffer;
};

partial interface TextTrack {
                attribute DOMString     kind;
                attribute DOMString     language;
    readonly    attribute SourceBuffer? sourceBuffer;
};

enum EndOfStreamError {
    "network",
    "decode"
};
enum AppendMode {
    "segments",
    "sequence"
};

enum ReadyState {
    "closed",
    "open",
    "ended"
};

</script>
<script>
"use strict";
var idlArray = new IdlArray();
var mediaSource = new MediaSource();
var sourceBuffer;
var sourceBufferList;
var video = document.createElement("video");
var videoPlaybackQuality;
if ("getVideoPlaybackQuality" in HTMLVideoElement.prototype) {
  videoPlaybackQuality = video.getVideoPlaybackQuality();
}
video.src = URL.createObjectURL(mediaSource);
function fetch(src, cb) {
  var xhr = new XMLHttpRequest();
  xhr.open("GET", src, true);
  xhr.responseType = "blob";
  xhr.addEventListener("load", function (e) {
    if (xhr.status != 200) {
      return false;
    }
    cb(xhr.response);
  });
  xhr.send();
};
mediaSource.addEventListener("sourceopen", function () {
  sourceBuffer = mediaSource.addSourceBuffer("video/webm");
  sourceBufferList = mediaSource.sourceBuffers;
  fetch("/resources/media/sunflower.webm", function (blob) {
    var r = new FileReader();
    r.addEventListener("load", function (e) {
      sourceBuffer.appendBuffer(new Uint8Array(e.target.result));
      mediaSource.endOfStream();
      video.play();
    });
    r.readAsArrayBuffer(blob);
  });
  [].forEach.call(document.querySelectorAll("script[type=text\\/plain]"), function(node) {
    if (node.className == "untested") {
      idlArray.add_untested_idls(node.textContent);
    } else {
      idlArray.add_idls(node.textContent);
    }
  });
  idlArray.add_objects({
    MediaSource: ['mediaSource'],
    SourceBuffer: ['sourceBuffer'],
    SourceBufferList: ['sourceBufferList'],
    VideoPlaybackQuality: ['videoPlaybackQuality'],
  });
  idlArray.test();
});
</script>
