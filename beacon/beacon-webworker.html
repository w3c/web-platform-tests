<!DOCTYPE html>
<html>
<head>
    <title>W3C Beacon Webworker Test</title>
    <meta name="timeout" content="long">
    <script src="/resources/testharness.js"></script>
    <script src="/resources/testharnessreport.js"></script>
</head>
<body>
    <script src="/common/utils.js"></script>
    <script src="beacon-common.js?pipe=sub"></script>
    <script>
        "use strict";

        // Run the sample tests from a webworker, terminating the webworker immediately
        // after it sends the beacon or keeping it alive.
        [true, false].forEach(function(terminateWorkerAfterSending) {
            // Implement the self.buildId extension to identify the parameterized
            // test in the report.
            self.buildId = function(baseId) {
                return `${baseId}-WW${terminateWorkerAfterSending ? "-TERMINATE": ""}`;
            };

            // Implement the self.sendFunc extension to send the beacon indirectly,
            // from a webworker.
            self.sendFunc = function(testCase) {
                var worker = new Worker("beacon-webworker.js");
                worker.onmessage = function(e) {
                    // The worker will execute sendData() for us and return the result.
                    var sendResult = e.data;
                    continueAfterSendingBeacon(sendResult, testCase);
                };

                // We run into problems passing the testCase over the process boundary,
                // because of structured cloning constraints. Instead we'll send over the
                // test case id, and the worker can load the static test case by including
                // beacon-common.js.
                worker.postMessage([testCase.origId, testCase.url, terminateWorkerAfterSending]);
            }

            runTests(sampleTests);
        });
    </script>
</body>
</html>