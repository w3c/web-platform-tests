<!doctype html>
<meta charset=utf-8>
<title>RTCPeerConnection.prototype.ondatachannel</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="RTCPeerConnection-helper.js"></script>
<script>
'use strict';

// Disable global timeout
// IMPORTANT: You need to add a timeout to *every test* of this file!
setup({ explicit_timeout: true });

// Test is based on the following revision:
// https://rawgit.com/w3c/webrtc-pc/1cc5bfc3ff18741033d804c4a71f7891242fb5b3/webrtc.html

// The following helper functions are called from RTCPeerConnection-helper.js:
// exchangeIceCandidates
// doSignalingHandshake
// createDataChannelPair

/*
  6.2.  RTCDataChannel
    When an underlying data transport is to be announced (the other peer created a channel with
    negotiated unset or set to false), the user agent of the peer that did not initiate the
    creation process MUST queue a task to run the following steps:
      2. Let channel be a newly created RTCDataChannel object.
      7. Set channel's [[ReadyState]] slot to connecting.
      7. Fire a datachannel event named datachannel with channel at the RTCPeerConnection object.

  6.3.  RTCDataChannelEvent
    Firing a datachannel event named e with an RTCDataChannel channel means that an event with the
    name e, which does not bubble (except where otherwise stated) and is not cancelable (except
    where otherwise stated), and which uses the RTCDataChannelEvent interface with the channel
    attribute set to channel, MUST be created and dispatched at the given target.

    interface RTCDataChannelEvent : Event {
      readonly attribute RTCDataChannel channel;
    };
 */
promise_test(async (t) => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  let eventCount = 0;

  const onDataChannel = t.step_func(event => {
    eventCount++;
    assert_equals(eventCount, 1,
      'Expect data channel event to fire exactly once');

    assert_true(event instanceof RTCDataChannelEvent,
      'Expect event to be instance of RTCDataChannelEvent');

    assert_equals(event.bubbles, false);
    assert_equals(event.cancelable, false);

    const dc = event.channel;
    assert_true(dc instanceof RTCDataChannel,
      'Expect channel to be instance of RTCDataChannel');

    // As long as this event handler runs, the channel should be in the 'connecting' state.
    // See: https://github.com/w3c/webrtc-pc/issues/1761
    assert_equals(dc.readyState, 'connecting',
      'Expect channel ready state to be connecting');

    t.done();
  });

  pc2.addEventListener('datachannel', onDataChannel);
  pc1.createDataChannel('fire-me!');
  exchangeIceCandidates(pc1, pc2);
  await doSignalingHandshake(pc1, pc2);

  await t.done_promise;
}, 'Data channel event should fire when new data channel is announced to the remote peer', {
  timeout: 5000
});

/*
  6.2.  RTCDataChannel

    interface RTCDataChannel : EventTarget {
      readonly attribute USVString           label;
      readonly attribute boolean             ordered;
      readonly attribute unsigned short?     maxPacketLifeTime;
      readonly attribute unsigned short?     maxRetransmits;
      readonly attribute USVString           protocol;
      readonly attribute boolean             negotiated;
      readonly attribute unsigned short?     id;
      readonly attribute RTCPriorityType     priority;
      readonly attribute RTCDataChannelState readyState;
      ...
    };

    When an underlying data transport is to be announced (the other peer created a channel with
    negotiated unset or set to false), the user agent of the peer that did not initiate the
    creation process MUST queue a task to run the following steps:
      2. Let channel be a newly created RTCDataChannel object.
      3. Let configuration be an information bundle received from the other peer as a part of the
         process to establish the underlying data transport described by the WebRTC DataChannel
         Protocol specification [RTCWEB-DATA-PROTOCOL].
      4. Initialize channel's [[DataChannelLabel]], [[Ordered]], [[MaxPacketLifeTime]],
         [[MaxRetransmits]], [[DataChannelProtocol]], and [[DataChannelId]] internal slots to the
         corresponding values in configuration.
      5. Initialize channel's [[Negotiated]] internal slot to false.
      6. Initialize channel's [[DataChannelPriority]] internal slot based on the integer priority
         value in configuration, [...]
      7. Set channel's [[ReadyState]] slot to connecting.
      8. Fire a datachannel event named datachannel with channel at the RTCPeerConnection object.

    Note: More exhaustive tests are defined in RTCDataChannel-dcep
 */

promise_test(async (t) => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  const localChannel = pc1.createDataChannel('test', {
    ordered: false,
    maxRetransmits: 1,
    protocol: 'custom',
    priority: 'high'
  });

  assert_equals(localChannel.label, 'test');
  assert_equals(localChannel.ordered, false);
  assert_equals(localChannel.maxRetransmits, 1);
  assert_equals(localChannel.protocol, 'custom');
  assert_equals(localChannel.negotiated, false);
  assert_equals(localChannel.priority, 'high');

  const onDataChannel = t.step_func(event => {
    const remoteChannel = event.channel;
    assert_true(remoteChannel instanceof RTCDataChannel,
      'Expect channel to be instance of RTCDataChannel');

    assert_equals(remoteChannel.label, 'test');
    assert_equals(remoteChannel.ordered, false);
    assert_equals(remoteChannel.maxRetransmits, 1);
    assert_equals(remoteChannel.protocol, 'custom');
    assert_equals(localChannel.negotiated, false);
    assert_equals(remoteChannel.id, localChannel.id);
    assert_equals(remoteChannel.priority, 'high');

    t.done();
  });

  pc2.addEventListener('datachannel', onDataChannel);
  exchangeIceCandidates(pc1, pc2);
  await doSignalingHandshake(pc1, pc2);

  await t.done_promise;
}, 'In-band negotiated channel created on remote peer should match the same configuration as local ' +
  'peer', {
  timeout: 5000
});

promise_test(async (t) => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  const localChannel = pc1.createDataChannel('');

  assert_equals(localChannel.label, '');
  assert_equals(localChannel.ordered, true);
  assert_equals(localChannel.maxPacketLifeTime, null);
  assert_equals(localChannel.maxRetransmits, null);
  assert_equals(localChannel.protocol, '');
  assert_equals(localChannel.negotiated, false);
  assert_equals(localChannel.priority, 'low');

  const onDataChannel = t.step_func(event => {
    const remoteChannel = event.channel;
    assert_true(remoteChannel instanceof RTCDataChannel,
      'Expect channel to be instance of RTCDataChannel');

    assert_equals(remoteChannel.label, '');
    assert_equals(remoteChannel.ordered, true);
    assert_equals(remoteChannel.maxPacketLifeTime, null);
    assert_equals(remoteChannel.maxRetransmits, null);
    assert_equals(remoteChannel.protocol, '');
    assert_equals(localChannel.negotiated, false);
    assert_equals(remoteChannel.id, localChannel.id);
    assert_equals(remoteChannel.priority, 'low');

    t.done();
  });

  pc2.addEventListener('datachannel', onDataChannel);
  exchangeIceCandidates(pc1, pc2);
  await doSignalingHandshake(pc1, pc2);

  await t.done_promise;
}, 'In-band negotiated channel created on remote peer should match the same (default) ' +
  'configuration as local peer', {
  timeout: 5000
});

/*
  6.2.  RTCDataChannel
    Dictionary RTCDataChannelInit Members
      negotiated
        The default value of false tells the user agent to announce the
        channel in-band and instruct the other peer to dispatch a corresponding
        RTCDataChannel object. If set to true, it is up to the application
        to negotiate the channel and create a RTCDataChannel object with the
        same id at the other peer.
 */
promise_test(async (t) => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  const onDataChannel = t.unreached_func('datachannel event should not be fired');

  pc1.createDataChannel('test', {
    negotiated: true
  });

  pc2.addEventListener('datachannel', onDataChannel);
  exchangeIceCandidates(pc1, pc2);
  await doSignalingHandshake(pc1, pc2);

  t.step_timeout(t.step_func_done(), 2000);
  await t.done_promise;
}, 'Negotiated channel should not fire datachannel event on remote peer', {
  timeout: 5000
});

/*
  Non-testable
  6.2.  RTCDataChannel
    When an underlying data transport is to be announced
      1.  If the associated RTCPeerConnection object's [[isClosed]] slot
          is true, abort these steps.

  The above step is not testable because to reach it we would have to
  close the peer connection just between receiving the in-band negotiated data
  channel via DCEP and firing the datachannel event.
 */
</script>
