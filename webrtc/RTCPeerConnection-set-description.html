<!doctype html>
<title>RTCPeerConnection Set Description tests</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script>
  'use strict';

  const audioLineRegex = /\r\nm=audio.+\r\n/g;
  const videoLineRegex = /\r\nm=video.+\r\n/g;

  function countAudioLine(sdp) {
    const matches = sdp.match(audioLineRegex);
    if(matches === null) {
      return 0;
    } else {
      return matches.length;
    }
  }

  function countVideoLine(sdp) {
    const matches = sdp.match(videoLineRegex);
    if(matches === null) {
      return 0;
    } else {
      return matches.length;
    }
  }

  function similarMediaDescriptions(sdp1, sdp2) {
    if(sdp1 === sdp2) {
      return true;
    } else if(countAudioLine(sdp1) !== countAudioLine(sdp2)) {
      return false;
    } else if(countVideoLine(sdp1) !== countVideoLine(sdp2)) {
      return false;
    } else {
      return true;
    }
  }

  // Assert that given object is either an
  // RTCSessionDescription or RTCSessionDescriptionInit
  function assert_is_session_description(sessionDesc) {
    if(sessionDesc instanceof RTCSessionDescription) {
      return;
    }

    assert_true(typeof(sessionDesc) === 'object',
      'Expect sessionDescription to be either a RTCSessionDescription or an object');

    assert_true(typeof(sessionDesc.type) === 'string',
      'Expect sessionDescription.type to be a string');

    assert_true(typeof(sessionDesc.type) === 'string',
      'Expect sessionDescription.sdp to be a string');
  }

  function isSimilarSessionDescription(sessionDesc1, sessionDesc2) {
    assert_is_session_description(sessionDesc1);
    assert_is_session_description(sessionDesc2);

    if(sessionDesc1.type !== sessionDesc2.type) {
      return false;
    } else {
      // We can't do string comparison to the SDP content,
      // because RTCPeerConnection may return SDP that is
      // slightly modified from what is given to it due to
      // ice candidate events or serialization.
      // To hack around this, if the SDP strings are not
      // equal, we simply count the media description lines
      // and if they are the same, we assume it is the same.
      return similarMediaDescriptions(sessionDesc1.sdp, sessionDesc2.sdp);
    }
  }

  function assert_session_desc_equals(sessionDesc1, sessionDesc2) {
    assert_true(isSimilarSessionDescription(sessionDesc1, sessionDesc2),
      'Expect essential content in both session descriptions to be the same');
  }

  function assert_session_desc_not_equals(sessionDesc1, sessionDesc2) {
    assert_false(isSimilarSessionDescription(sessionDesc1, sessionDesc2),
      'Expect essential content in both session descriptions to be different');
  }

  function createOfferAndSetLocal(pc, options) {
    return pc.createOffer(options)
    .then(offer =>
      pc.setLocalDescription(offer)
      .then(() => offer));
  }

  function createOfferAndSetRemote(pc1, pc2, options) {
    return createOfferAndSetLocal(pc1, options)
    .then(offer =>
      pc2.setRemoteDescription(offer)
      .then(() => offer));
  }

  function createOfferAndGetAnswer(pc1, pc2, options) {
    return createOfferAndSetRemote(pc1, pc2, options)
    .then(offer =>
      pc2.createAnswer(offer)
      .then(answer => [offer, answer]))
  }

  function createAnswerAndSetLocal(pc1, pc2, options) {
    return createOfferAndGetAnswer(pc1, pc2, options)
    .then(([offer, answer]) =>
      pc2.setLocalDescription(answer)
      .then(() => [offer, answer]));
  }

  function createAnswerAndSetRemote(pc1, pc2, options) {
    return createAnswerAndSetLocal(pc1, pc2, options)
    .then(([offer, answer]) =>
      pc1.setRemoteDescription(answer)
      .then(() => [offer, answer]));
  }

  promise_test(t => {
    const pc = new RTCPeerConnection;
    return createOfferAndSetLocal(pc)
    .then(offer => {
      assert_equals(pc.signalingState, 'have-local-offer');
      assert_session_desc_equals(pc.localDescription, offer);
      assert_session_desc_equals(pc.pendingLocalDescription, offer);
      assert_equals(pc.currentLocalDescription, null);
    });
  }, 'Create and set offer');

  promise_test(t => {
    const pc = new RTCPeerConnection;
    return pc.createOffer()
    .then(offer =>
      pc.setLocalDescription({ type: 'offer' })
      .then(() => {
        assert_equals(pc.signalingState, 'have-local-offer');
        assert_session_desc_equals(pc.localDescription, offer);
        assert_session_desc_equals(pc.pendingLocalDescription, offer);
        assert_equals(pc.currentLocalDescription, null);
      }));
  }, 'setLocalDescription with type offer and empty sdp should use lastOffer generated from createOffer');

  promise_test(t => {
    const pc = new RTCPeerConnection;
    return pc.createOffer({ offerToReceiveAudio: true })
    .then(offer1 =>
      pc.createOffer({ offerToReceiveVideo: true })
      .then(offer2 => {
        assert_not_equals(offer1.sdp, offer2.sdp);
        return promise_rejects(t, 'InvalidModificationError',
          pc.setLocalDescription(offer1));
      }));
  }, 'Cannot set offer different from last offer');

  promise_test(t => {
    const pc = new RTCPeerConnection;
    return createOfferAndSetLocal(pc, { offerToReceiveAudio: true })
    .then(offer1 =>
       createOfferAndSetLocal(pc, { offerToReceiveVideo: true })
      .then(offer2 => {
        assert_not_equals(offer1.sdp, offer2.sdp);
        assert_equals(pc.signalingState, 'have-local-offer');
        assert_session_desc_equals(pc.localDescription, offer2);
        assert_session_desc_equals(pc.pendingLocalDescription, offer2);
        assert_equals(pc.currentLocalDescription, null);
      }));
  }, 'Can create and set offer multiple times');

  promise_test(t => {
    const pc1 = new RTCPeerConnection;
    const pc2 = new RTCPeerConnection;

    return createOfferAndSetRemote(pc1, pc2)
    .then(offer => {
      assert_equals(pc2.signalingState, 'have-remote-offer');
      assert_session_desc_equals(pc2.remoteDescription, offer);
      assert_session_desc_equals(pc2.pendingRemoteDescription, offer);
      assert_equals(pc2.localRemoteDescription, null);
    });
  }, 'Create and set remote offer');

  promise_test(t => {
    const pc1 = new RTCPeerConnection;
    const pc2 = new RTCPeerConnection;

    return createOfferAndSetRemote(pc1, pc2, { offerToReceiveAudio: true })
    .then(offer1 =>
      createOfferAndSetRemote(pc1, pc2, { offerToReceiveVideo: true })
      .then(offer2 => {
        assert_not_equals(offer1.sdp, offer2.sdp);
        assert_equals(pc2.signalingState, 'have-remote-offer');
        assert_session_desc_equals(pc2.remoteDescription, offer2);
        assert_session_desc_equals(pc2.pendingRemoteDescription, offer2);
        assert_equals(pc2.currentRemoteDescription, null);
      }));
  }, 'Can set remote description multiple times');

  promise_test(t => {
    const pc = new RTCPeerConnection;
    return promise_rejects(t, 'InvalidStateError',
      pc.createAnswer());

  }, 'Cannot create answer with null remoteDescription');

  promise_test(t => {
    const pc1 = new RTCPeerConnection;
    const pc2 = new RTCPeerConnection;

    return createOfferAndGetAnswer(pc1, pc2)
    .then(([offer, answer]) => {
      assert_equals(answer.type, 'answer');
      const sdp = answer.sdp;
      assert_true(typeof(sdp) === 'string');
      assert_greater_than(sdp.length, 0);
    });
  }, 'Can create answer after setting remote description');

  promise_test(t => {
    const pc1 = new RTCPeerConnection;
    const pc2 = new RTCPeerConnection;

    return createAnswerAndSetLocal(pc1, pc2)
    .then(([offer, answer]) => {
      assert_equals(pc2.signalingState, 'stable');
      assert_session_desc_equals(pc2.localDescription, answer);
      assert_session_desc_equals(pc2.remoteDescription, offer);

      assert_session_desc_equals(pc2.currentLocalDescription, answer);
      assert_session_desc_equals(pc2.currentRemoteDescription, offer);

      assert_equals(pc2.pendingLocalDescription, null);
      assert_equals(pc2.pendingRemoteDescription, null);
    });
  }, 'Create and set local answer');

  promise_test(t => {
    const pc1 = new RTCPeerConnection;
    const pc2 = new RTCPeerConnection;

    return createOfferAndGetAnswer(pc1, pc2)
    .then(([offer, answer]) => {
      return pc2.setLocalDescription({ type: 'answer' })
      .then(() => {
        assert_equals(pc2.signalingState, 'stable');
        assert_session_desc_equals(pc2.localDescription, answer);
        assert_session_desc_equals(pc2.remoteDescription, offer);

        assert_session_desc_equals(pc2.currentLocalDescription, answer);
        assert_session_desc_equals(pc2.currentRemoteDescription, offer);

        assert_equals(pc2.pendingLocalDescription, null);
        assert_equals(pc2.pendingRemoteDescription, null);
      });
    });
  }, 'setLocalDescription with type answer and empty sdp should use lastAnswer generated from createAnswer');

  promise_test(t => {
    const pc1 = new RTCPeerConnection;
    const pc2 = new RTCPeerConnection;

    return createAnswerAndSetRemote(pc1, pc2)
    .then(([offer, answer]) => {
      assert_equals(pc1.signalingState, 'stable');
      assert_session_desc_equals(pc1.localDescription, offer);
      assert_session_desc_equals(pc1.remoteDescription, answer);

      assert_session_desc_equals(pc1.currentLocalDescription, offer);
      assert_session_desc_equals(pc1.currentRemoteDescription, answer);

      assert_equals(pc1.pendingLocalDescription, null);
      assert_equals(pc1.pendingRemoteDescription, null);
    });
  }, 'Create and set remote answer');

  promise_test(t => {
    const pc1 = new RTCPeerConnection;
    const pc2 = new RTCPeerConnection;

    return createAnswerAndSetRemote(pc1, pc2, {
      offerToReceiveAudio: true
    }).then(([offer1, answer1]) => {
      return createOfferAndSetLocal(pc1, {
        offerToReceiveVideo: true
      }).then(offer2 => {
        assert_equals(pc1.signalingState, 'have-local-offer');
        assert_session_desc_not_equals(offer1, offer2);
        assert_session_desc_equals(pc1.localDescription, offer1);
        assert_session_desc_equals(pc1.currentLocalDescription, offer1);
        assert_session_desc_equals(pc1.pendingLocalDescription, offer2);

        return pc2.setRemoteDescription(offer2)
        .then(() => pc2.createAnswer())
        .then(answer2 => {
          assert_equals(pc2.signalingState, 'have-remote-offer');
          assert_session_desc_not_equals(answer1, answer2);
          assert_session_desc_equals(pc2.remoteDescription, answer1);
          assert_session_desc_equals(pc2.currentRemoteDescription, answer1);
          assert_session_desc_equals(pc2.pendingRemoteDescription, answer2);
        });
      });
    });
  }, 'Create offer again after go back to stable state');

  promise_test(t => {
    const pc = new RTCPeerConnection;

    return pc.createOffer()
    .then(offer =>
      promise_rejects(t, 'InvalidStateError',
        pc.setRemoteDescription({ type: 'answer', sdp: offer.sdp })));
  }, 'Cannot set remote answer from stable state');

  promise_test(t => {
    const pc = new RTCPeerConnection;

    return pc.createOffer()
    .then(offer =>
      promise_rejects(t, 'InvalidStateError',
        pc.setLocalDescription({ type: 'answer', sdp: offer.sdp })));

  }, 'Cannot set local answer from stable state');

  promise_test(t => {
    const pc = new RTCPeerConnection;

    return createOfferAndSetLocal(pc)
    .then(offer =>
      promise_rejects(t, 'InvalidStateError',
        pc.setRemoteDescription(offer)));
  }, 'Cannot set remote offer from have-local-offer state');

  promise_test(t => {
    const pc = new RTCPeerConnection;

    return createOfferAndSetLocal(pc)
    .then(offer =>
      promise_rejects(t, 'InvalidStateError',
        pc.setLocalDescription({ type: 'answer', sdp: offer.sdp })));
  }, 'Cannot set local answer from have-local-offer state');

  promise_test(t => {
    const pc1 = new RTCPeerConnection;
    const pc2 = new RTCPeerConnection;

    return createOfferAndSetRemote(pc1, pc2)
    .then(offer =>
      promise_rejects(t, 'InvalidStateError',
        pc2.setRemoteDescription({ type: 'answer', sdp: offer.sdp })));
  }, 'Cannot set remote answer from have-remote-offer state');

  promise_test(t => {
    const pc = new RTCPeerConnection;

    return pc.createOffer({ offerToReceiveAudio: true })
    .then(offer1 => {
      assert_greater_than(countAudioLine(offer1.sdp), 0);

      // The first createOffer implicitly calls addTransceiver('audio'),
      // so all following offers will also have audio media section
      // in their SDP.
      return pc.createOffer({ offerToReceiveAudio: false })
      .then(offer2 => {
        assert_greater_than(countAudioLine(offer2.sdp), 0);
      })
    });
  }, 'Create with offer to receive audio');

  promise_test(t => {
    const pc = new RTCPeerConnection;

    return pc.createOffer({ offerToReceiveVideo: true })
    .then(offer1 => {
      assert_greater_than(countVideoLine(offer1.sdp), 0);

      return pc.createOffer({ offerToReceiveVideo: false })
      .then(offer2 => {
        assert_greater_than(countVideoLine(offer2.sdp), 0);
      })
    });
  }, 'Create with offer to receive video');

  promise_test(t => {
    const pc = new RTCPeerConnection;

    return pc.createOffer({
      offerToReceiveAudio: true,
      offerToReceiveVideo: false
    }).then(offer1 => {
      assert_greater_than(countAudioLine(offer1.sdp), 0);

      return pc.createOffer({
        offerToReceiveAudio: false,
        offerToReceiveVideo: true
      }).then(offer2 => {
        assert_greater_than(countAudioLine(offer2.sdp), 0);
        assert_greater_than(countVideoLine(offer2.sdp), 0);
      })
    });
  }, 'Create with offer to receive audio then video');

  // TODO: Add tests for rollback, provisional offer/answer, etc

</script>
