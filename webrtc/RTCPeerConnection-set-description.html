<!doctype html>
<title>RTCPeerConnection Set Description tests</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script type="text/javascript">
  'use strict';

  function assert_defined(object) {
    if(object === undefined || object === null)
      assert_unreached('object must not be undefined or null');
  }

  function assert_equal_sdp(sdp1, sdp2) {
    assert_defined(sdp1);
    assert_defined(sdp2);
    assert_equals(sdp1.type, sdp2.type);
    assert_equals(sdp1.sdp, sdp2.sdp);
  }

  function createOfferAndSetLocal(pc, options) {
    return pc.createOffer(options)
    .then(offer => {
      return pc.setLocalDescription(offer)
      .then(() => offer)
    });
  }

  function createOfferAndSetRemote(pc1, pc2, options) {
    return createOfferAndSetLocal(pc1, options)
    .then(offer =>
      pc2.setRemoteDescription(offer)
      .then(() => offer));
  }

  function createOfferAndGetAnswer(pc1, pc2, options) {
    return createOfferAndSetRemote(pc1, pc2, options)
    .then(offer =>
      pc2.createAnswer(offer)
      .then(answer => [offer, answer]))
  }

  function createAnswerAndSetLocal(pc1, pc2, options) {
    return createOfferAndGetAnswer(pc1, pc2, options)
    .then(([offer, answer]) =>
      pc2.setLocalDescription(answer)
      .then(() => [offer, answer]));
  }

  function createAnswerAndSetRemote(pc1, pc2, options) {
    return createAnswerAndSetLocal(pc1, pc2, options)
    .then(([offer, answer]) =>
      pc1.setRemoteDescription(answer)
      .then(() => [offer, answer]));
  }

  test(t => {
    const pc = new RTCPeerConnection;
    assert_equals(pc.signalingState, 'stable');
    assert_equals(pc.localDescription, null);
    assert_equals(pc.currentLocalDescription, null);
    assert_equals(pc.pendingLocalDescription, null);
    assert_equals(pc.remoteDescription, null);
    assert_equals(pc.currentRemoteDescription, null);
    assert_equals(pc.pendingRemoteDescription, null);
  }, 'Initial peer connection state');

  promise_test(t => {
    const pc = new RTCPeerConnection;
    return createOfferAndSetLocal(pc)
    .then(offer => {
      assert_equals(pc.signalingState, 'have-local-offer');
      assert_equal_sdp(pc.localDescription, offer);
      assert_equal_sdp(pc.pendingLocalDescription, offer);
      assert_equals(pc.currentLocalDescription, null);
    });
  }, 'Create and set offer');

  promise_test(t => {
    const pc = new RTCPeerConnection;
    return pc.createOffer()
    .then(offer =>
      pc.setLocalDescription({ type: 'offer' })
      .then(() => {
        assert_equals(pc.signalingState, 'have-local-offer');
        assert_equal_sdp(pc.localDescription, offer);
        assert_equal_sdp(pc.pendingLocalDescription, offer);
        assert_equals(pc.currentLocalDescription, null);
      }));
  }, 'Create and set default offer');

  promise_test(t => {
    const pc = new RTCPeerConnection;
    return pc.createOffer({ offerToReceiveAudio: true })
    .then(offer1 =>
      pc.createOffer({ offerToReceiveVideo: true })
      .then(offer2 => {
        assert_not_equals(offer1.sdp, offer2.sdp);
        return promise_rejects(t, 'InvalidModificationError',
          pc.setLocalDescription(offer1));
      }));
  }, 'Cannot set offer different from last offer');

  promise_test(t => {
    const pc = new RTCPeerConnection;
    return createOfferAndSetLocal(pc, { offerToReceiveAudio: true })
    .then(offer1 =>
       createOfferAndSetLocal(pc, { offerToReceiveVideo: true })
      .then(offer2 => {
        assert_not_equals(offer1.sdp, offer2.sdp);
        assert_equals(pc.signalingState, 'have-local-offer');

        // TODO: Fix race condition when comparing
        // as pc will trigger ice candidate gathering on
        // setLocalDescription and modify its sdp when
        // ice candidates become available
        assert_equal_sdp(pc.localDescription, offer2);
        assert_equal_sdp(pc.pendingLocalDescription, offer2);
        assert_equals(pc.currentLocalDescription, null);
      }));
  }, 'Can create and set offer multiple times');

  promise_test(t => {
    const pc1 = new RTCPeerConnection;
    const pc2 = new RTCPeerConnection;

    return createOfferAndSetRemote(pc1, pc2)
    .then(offer => {
      assert_equals(pc2.signalingState, 'have-remote-offer');
      assert_equal_sdp(pc2.remoteDescription, offer);
      assert_equal_sdp(pc2.pendingRemoteDescription, offer);
      assert_equals(pc2.localRemoteDescription, null);
    });
  }, 'Create and set remote offer');

  promise_test(t => {
    const pc1 = new RTCPeerConnection;
    const pc2 = new RTCPeerConnection;

    return createOfferAndSetRemote(pc1, pc2, { offerToReceiveAudio: true })
    .then(offer1 =>
      createOfferAndSetRemote(pc1, pc2, { offerToReceiveVideo: true })
      .then(offer2 => {
        assert_not_equals(offer1.sdp, offer2.sdp);
        assert_equals(pc2.signalingState, 'have-remote-offer');
        assert_equal_sdp(pc2.remoteDescription, offer2);
        assert_equal_sdp(pc2.pendingRemoteDescription, offer2);
        assert_equals(pc2.currentRemoteDescription, null);
      }));
  }, 'Can set remote description multiple times');

  promise_test(t => {
    const pc = new RTCPeerConnection;
    return promise_rejects(t, 'InvalidStateError',
      pc.createAnswer());

  }, 'Cannot create answer with null remoteDescription');

  promise_test(t => {
    const pc1 = new RTCPeerConnection;
    const pc2 = new RTCPeerConnection;

    return createOfferAndGetAnswer(pc1, pc2)
    .then(([offer, answer]) => {
      assert_equals(answer.type, 'answer');
      const sdp = answer.sdp;
      assert_true(typeof(sdp) === 'string');
      assert_greater_than(sdp.length, 0);
    });
  }, 'Can create answer after setting remote description');

  promise_test(t => {
    const pc1 = new RTCPeerConnection;
    const pc2 = new RTCPeerConnection;

    return createAnswerAndSetLocal(pc1, pc2)
    .then(([offer, answer]) => {
      assert_equals(pc2.signalingState, 'stable');
      assert_equal_sdp(pc2.localDescription, answer);
      assert_equal_sdp(pc2.remoteDescription, offer);

      assert_equal_sdp(pc2.currentLocalDescription, answer);
      assert_equal_sdp(pc2.currentRemoteDescription, offer);

      assert_equals(pc2.pendingLocalDescription, null);
      assert_equals(pc2.pendingRemoteDescription, null);
    });
  }, 'Create and set local answer');

  promise_test(t => {
    const pc1 = new RTCPeerConnection;
    const pc2 = new RTCPeerConnection;

    return createAnswerAndSetRemote(pc1, pc2)
    .then(([offer, answer]) => {
      assert_equals(pc1.signalingState, 'stable');
      assert_equal_sdp(pc1.localDescription, offer);
      assert_equal_sdp(pc1.remoteDescription, answer);

      assert_equal_sdp(pc1.currentLocalDescription, offer);
      assert_equal_sdp(pc1.currentRemoteDescription, answer);

      assert_equals(pc1.pendingLocalDescription, null);
      assert_equals(pc1.pendingRemoteDescription, null);
    });
  }, 'Create and set remote answer');

  promise_test(t => {
    const pc = new RTCPeerConnection;

    return pc.createOffer()
    .then(offer =>
      promise_rejects(t, 'InvalidStateError',
        pc.setRemoteDescription({ type: 'answer', sdp: offer.sdp })));
  }, 'Cannot set remote answer from stable state');

  promise_test(t => {
    const pc = new RTCPeerConnection;

    return pc.createOffer()
    .then(offer =>
      promise_rejects(t, 'InvalidStateError',
        pc.setLocalDescription({ type: 'answer', sdp: offer.sdp })));

  }, 'Cannot set local answer from stable state');

  promise_test(t => {
    const pc = new RTCPeerConnection;

    return createOfferAndSetLocal(pc)
    .then(offer =>
      promise_rejects(t, 'InvalidStateError',
        pc.setRemoteDescription(offer)));
  }, 'Cannot set remote offer from have-local-offer state');

  promise_test(t => {
    const pc = new RTCPeerConnection;

    return createOfferAndSetLocal(pc)
    .then(offer =>
      promise_rejects(t, 'InvalidStateError',
        pc.setLocalDescription({ type: 'answer', sdp: offer.sdp })));
  }, 'Cannot set local answer from have-local-offer state');

  promise_test(t => {
    const pc1 = new RTCPeerConnection;
    const pc2 = new RTCPeerConnection;

    return createOfferAndSetRemote(pc1, pc2)
    .then(offer =>
      promise_rejects(t, 'InvalidStateError',
        pc2.setRemoteDescription({ type: 'answer', sdp: offer.sdp })));
  }, 'Cannot set remote answer from have-remote-offer state');

  // TODO: Add tests for rollback, provisional offer/answer, etc

</script>
