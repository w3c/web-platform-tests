<!doctype html>
<meta charset=utf-8>
<title>RTCPeerConnection Set Description tests</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script>
  'use strict';

  const audioLineRegex = /\r\nm=audio.+\r\n/g;
  const videoLineRegex = /\r\nm=video.+\r\n/g;
  const applicationLineRegex = /\r\nm=application.+\r\n/g;

  function countLine(sdp, regex) {
    const matches = sdp.match(regex);
    if(matches === null) {
      return 0;
    } else {
      return matches.length;
    }
  }

  function countAudioLine(sdp) {
    return countLine(sdp, audioLineRegex);
  }

  function countVideoLine(sdp) {
    return countLine(sdp, videoLineRegex);
  }

  function countApplicationLine(sdp) {
    return countLine(sdp, applicationLineRegex);
  }

  function similarMediaDescriptions(sdp1, sdp2) {
    if(sdp1 === sdp2) {
      return true;
    } else if(
      countAudioLine(sdp1) !== countAudioLine(sdp2) ||
      countVideoLine(sdp1) !== countVideoLine(sdp2) ||
      countApplicationLine(sdp1) !== countApplicationLine(sdp2))
    {
      return false;
    } else {
      return true;
    }
  }

  // Assert that given object is either an
  // RTCSessionDescription or RTCSessionDescriptionInit
  function assert_is_session_description(sessionDesc) {
    if(sessionDesc instanceof RTCSessionDescription) {
      return;
    }

    assert_true(typeof(sessionDesc) === 'object',
      'Expect sessionDescription to be either a RTCSessionDescription or an object');

    assert_true(typeof(sessionDesc.type) === 'string',
      'Expect sessionDescription.type to be a string');

    assert_true(typeof(sessionDesc.type) === 'string',
      'Expect sessionDescription.sdp to be a string');
  }


  // We can't do string comparison to the SDP content,
  // because RTCPeerConnection may return SDP that is
  // slightly modified or reordered from what is given
  // to it due to ICE candidate events or serialization.
  // Instead, we create SDP with different number of media
  // lines, and if the SDP strings are not the same, we
  // simply count the media description lines and if they
  // are the same, we assume it is the same.
  function isSimilarSessionDescription(sessionDesc1, sessionDesc2) {
    assert_is_session_description(sessionDesc1);
    assert_is_session_description(sessionDesc2);

    if(sessionDesc1.type !== sessionDesc2.type) {
      return false;
    } else {
      return similarMediaDescriptions(sessionDesc1.sdp, sessionDesc2.sdp);
    }
  }

  function assert_session_desc_equals(sessionDesc1, sessionDesc2) {
    assert_true(isSimilarSessionDescription(sessionDesc1, sessionDesc2),
      'Expect both session descriptions to have the same count of media lines');
  }

  function assert_session_desc_not_equals(sessionDesc1, sessionDesc2) {
    assert_false(isSimilarSessionDescription(sessionDesc1, sessionDesc2),
      'Expect both session descriptions to have different count of media lines');
  }

  // Helper function to generate offer using a freshly created RTCPeerConnection
  // object with any audio, video, data media lines present
  function generateOffer(options={}) {
    const {
      audio=false,
      video=false,
      data=false
    } = options;

    const pc = new RTCPeerConnection();

    if(data) {
      pc.createDataChannel('test');
    }

    return pc.createOffer({
      offerToReceiveAudio: audio,
      offerToReceiveVideo: video
    }).then(offer => {
      // Guard here to ensure that the generated offer really
      // contain the number of media lines we want
      const { sdp } = offer;

      if(audio) {
        assert_equals(countAudioLine(sdp), 1,
          'Expect m=audio line to be present in generated SDP');
      } else {
        assert_equals(countAudioLine(sdp), 0,
          'Expect m=audio line to be present in generated SDP');
      }

      if(video) {
        assert_equals(countVideoLine(sdp), 1,
          'Expect m=video line to be present in generated SDP');
      } else {
        assert_equals(countVideoLine(sdp), 0,
          'Expect m=video line to not present in generated SDP');
      }

      if(data) {
        assert_equals(countApplicationLine(sdp), 1,
          'Expect m=application line to be present in generated SDP');
      } else {
        assert_equals(countApplicationLine(sdp), 0,
          'Expect m=application line to not present in generated SDP');
      }

      return offer;
    });
  }

  // Helper function to generate answer based on given offer using a freshly
  // created RTCPeerConnection object
  function generateAnswer(offer) {
    const pc = new RTCPeerConnection();
    return pc.setRemoteDescription(offer)
    .then(() => pc.createAnswer());
  }

  // Wait for peer connection to fire onsignalingstatechange
  // event, compare and make sure the new state is the same
  // as expected state. It accepts an RTCPeerConnection object
  // and an array of expected state changes. The test passes
  // if all expected state change events have been fired, and
  // fail if the new state is different from the expected state.
  //
  // Note that the promise is never resolved if no change
  // event is fired. To avoid confusion with the main test
  // getting timed out, this is done in parallel as a separate
  // test
  function test_state_change_event(parentTest, pcName, pc, expectedStates) {
    return async_test(t => {
      pc.onsignalingstatechange = t.step_func(() => {
        if(expectedStates.length === 0) {
          return;
        }

        const newState = pc.signalingState;
        const expectedState = expectedStates.shift();

        assert_equals(newState, expectedState, 'New signaling state is different from expected.');

        if(expectedStates.length === 0) {
          t.done();
        }
      });
    }, `Test onsignalingstatechange event for ${pcName} in ${parentTest.name}`);
  }

  promise_test(t => {
    const pc = new RTCPeerConnection();
    test_state_change_event(t, 'pc', pc, ['have-local-offer']);

    return pc.createOffer()
    .then(offer =>
      pc.setLocalDescription(offer)
      .then(offer => {
        assert_equals(pc.signalingState, 'have-local-offer');
        assert_session_desc_equals(pc.localDescription, offer);
        assert_session_desc_equals(pc.pendingLocalDescription, offer);
        assert_equals(pc.currentLocalDescription, null);
      }));
  }, 'createOffer() and then setLocalDescription() should succeed');

  promise_test(t => {
    const pc = new RTCPeerConnection();
    return pc.createOffer()
    .then(offer =>
      pc.setLocalDescription({ type: 'offer' })
      .then(() => {
        assert_equals(pc.signalingState, 'have-local-offer');
        assert_session_desc_equals(pc.localDescription, offer);
        assert_session_desc_equals(pc.pendingLocalDescription, offer);
        assert_equals(pc.currentLocalDescription, null);
      }));
  }, 'setLocalDescription with type offer and empty sdp should use lastOffer generated from createOffer');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    return generateOffer({ data: true })
    .then(offer =>
      promise_rejects(t, 'InvalidModificationError',
        pc.setLocalDescription(offer)));
  }, 'setLocalDescription() with offer not created by own createOffer() should reject with InvalidModificationError');

  promise_test(t => {
    // Create first offer with audio line, then second offer with
    // both audio and video line. Since the second offer is the
    // last offer, setLocalDescription would reject when setting
    // with the first offer
    const pc = new RTCPeerConnection();
    return pc.createOffer({ offerToReceiveAudio: true })
    .then(offer1 =>
      pc.createOffer({ offerToReceiveVideo: true })
      .then(offer2 => {
        assert_session_desc_not_equals(offer1, offer2);
        return promise_rejects(t, 'InvalidModificationError',
          pc.setLocalDescription(offer1));
      }));
  }, 'Set created offer other than last offer should reject with InvalidModificationError');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    // Only one state change event should be fired
    test_state_change_event(t, 'pc', pc, ['have-local-offer']);

    return pc.createOffer({ offerToReceiveAudio: true })
    .then(offer1 =>
      pc.setLocalDescription(offer1)
      .then(() =>
        pc.createOffer({ offerToReceiveVideo: true })
        .then(offer2 =>
          pc.setLocalDescription(offer2)
          .then(offer2 => {
            assert_session_desc_not_equals(offer1, offer2);
            assert_equals(pc.signalingState, 'have-local-offer');
            assert_session_desc_equals(pc.localDescription, offer2);
            assert_session_desc_equals(pc.pendingLocalDescription, offer2);
            assert_equals(pc.currentLocalDescription, null);
          }))));
  }, 'Creating and setting offer multiple times should succeed');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    test_state_change_event(t, 'pc', pc, ['have-remote-offer']);

    return generateOffer({ data: true })
    .then(offer =>
      pc.setRemoteDescription(offer)
      .then(offer => {
        assert_equals(pc.signalingState, 'have-remote-offer');
        assert_session_desc_equals(pc.remoteDescription, offer);
        assert_session_desc_equals(pc.pendingRemoteDescription, offer);
        assert_equals(pc.currentRemoteDescription, null);
      }));
  }, 'setRemoteDescription with valid offer should succeed');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    // have-remote-offer event should only fire once
    test_state_change_event(t, 'pc', pc, ['have-remote-offer']);

    return Promise.all([
      generateOffer({ audio: true }),
      generateOffer({ data: true })
    ]).then(([offer1, offer2]) =>
      pc.setRemoteDescription(offer1)
      .then(() => pc.setRemoteDescription(offer2))
      .then(() => {
        assert_equals(pc.signalingState, 'have-remote-offer');
        assert_session_desc_equals(pc.remoteDescription, offer2);
        assert_session_desc_equals(pc.pendingRemoteDescription, offer2);
        assert_equals(pc.currentRemoteDescription, null);
      }));
  }, 'Setting remote description multiple times with different offer should succeed');

  promise_test(t => {
    const pc = new RTCPeerConnection();
    return promise_rejects(t, 'InvalidStateError',
      pc.createAnswer());
  }, 'createAnswer() with null remoteDescription should reject with InvalidStateError');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    return generateOffer({ video: true })
    .then(offer =>
      pc.setRemoteDescription(offer)
      .then(() => pc.createAnswer(offer)))
    .then(answer => {
      assert_is_session_description(answer);
    });
  }, 'createAnswer() after setting remote description should succeed');

  promise_test(t => {
    const pc = new RTCPeerConnection();
    test_state_change_event(t, 'pc', pc, ['have-remote-offer', 'stable']);

    return generateOffer({ video: true })
    .then(offer =>
      pc.setRemoteDescription(offer)
      .then(() => pc.createAnswer(offer))
      .then(answer =>
        pc.setLocalDescription(answer)
        .then(() => {
          assert_equals(pc.signalingState, 'stable');
          assert_session_desc_equals(pc.localDescription, answer);
          assert_session_desc_equals(pc.remoteDescription, offer);

          assert_session_desc_equals(pc.currentLocalDescription, answer);
          assert_session_desc_equals(pc.currentRemoteDescription, offer);

          assert_equals(pc.pendingLocalDescription, null);
          assert_equals(pc.pendingRemoteDescription, null);
        })));
  }, 'setLocalDescription() with valid answer should succeed');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    return generateOffer({ video: true })
    .then(offer =>
      pc.setRemoteDescription(offer)
      .then(() => pc.createAnswer(offer))
      .then(answer =>
        pc.setLocalDescription({ type: 'answer' })
        .then(() => {
          assert_equals(pc.signalingState, 'stable');
          assert_session_desc_equals(pc.localDescription, answer);
          assert_session_desc_equals(pc.remoteDescription, offer);

          assert_session_desc_equals(pc.currentLocalDescription, answer);
          assert_session_desc_equals(pc.currentRemoteDescription, offer);

          assert_equals(pc.pendingLocalDescription, null);
          assert_equals(pc.pendingRemoteDescription, null);
        })));
  }, 'setLocalDescription() with type answer and empty sdp should use lastAnswer generated from createAnswer');


  promise_test(t => {
    const pc = new RTCPeerConnection();

    return generateOffer({ video: true })
    .then(offer =>
      pc.setRemoteDescription(offer)
      .then(() => generateAnswer(offer))
      .then(answer =>
        promise_rejects(t, 'InvalidModificationError',
          pc.setLocalDescription(answer))));
  }, 'setLocalDescription() with answer not created by own createAnswer() should reject with InvalidModificationError');

  promise_test(t => {
    const pc = new RTCPeerConnection();
    test_state_change_event(t, 'pc', pc, ['have-local-offer', 'stable']);

    return pc.createOffer({ offerToReceiveVideo: true })
    .then(offer =>
      pc.setLocalDescription(offer)
      .then(() => generateAnswer(offer))
      .then(answer =>
        pc.setRemoteDescription(answer)
        .then(() => {
          assert_session_desc_equals(pc.localDescription, offer);
          assert_session_desc_equals(pc.remoteDescription, answer);

          assert_session_desc_equals(pc.currentLocalDescription, offer);
          assert_session_desc_equals(pc.currentRemoteDescription, answer);

          assert_equals(pc.pendingLocalDescription, null);
          assert_equals(pc.pendingRemoteDescription, null);
        })));
  }, 'setRemoteDescription() with valid state and answer should succeed');

  promise_test(t => {
    const pc = new RTCPeerConnection();
    test_state_change_event(t, 'pc', pc, ['have-local-offer', 'stable', 'have-local-offer']);

    return pc.createOffer({ offerToReceiveAudio: true })
    .then(offer1 =>
      pc.setLocalDescription(offer1)
      .then(() => generateAnswer(offer1))
      .then(answer => pc.setRemoteDescription(answer))
      .then(() => {
        pc.createDataChannel('test');
        return pc.createOffer({ offerToReceiveVideo: true });
      })
      .then(offer2 =>
        pc.setLocalDescription(offer2)
        .then(() => {
          assert_equals(pc.signalingState, 'have-local-offer');
          assert_session_desc_not_equals(offer1, offer2);
          assert_session_desc_equals(pc.localDescription, offer2);
          assert_session_desc_equals(pc.currentLocalDescription, offer1);
          assert_session_desc_equals(pc.pendingLocalDescription, offer2);
        })));
  }, 'Calling createOffer() and setLocalDescription() again after one round of local-offer/remote-answer should succeed');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    test_state_change_event(t, 'pc', pc,
      ['have-remote-offer', 'stable', 'have-remote-offer']);

    return generateOffer({ audio: true })
    .then(offer1 =>
      pc.setRemoteDescription(offer1)
      .then(() => pc.createAnswer())
      .then(answer => pc.setLocalDescription(answer))
      .then(() => generateOffer({ data: true }))
      .then(offer2 =>
        pc.setRemoteDescription(offer2)
        .then(() => {
          assert_equals(pc.signalingState, 'have-remote-offer');
          assert_session_desc_not_equals(offer1, offer2);
          assert_session_desc_equals(pc.remoteDescription, offer2);
          assert_session_desc_equals(pc.currentRemoteDescription, offer1);
          assert_session_desc_equals(pc.pendingRemoteDescription, offer2);
        })));
  }, 'Calling setRemoteDescription() again after one round of remote-offer/local-answer should succeed');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    test_state_change_event(t, 'pc', pc,
       ['have-local-offer', 'stable', 'have-remote-offer']);

    return pc.createOffer({ offerToReceiveAudio: true })
    .then(offer =>
      pc.setLocalDescription(offer)
      .then(() => generateAnswer(offer)))
    .then(answer =>
      pc.setRemoteDescription(answer)
      .then(() => generateOffer({ data: true }))
      .then(offer =>
        pc.setRemoteDescription(offer)
        .then(() => {
          assert_equals(pc.signalingState, 'have-remote-offer');
          assert_session_desc_equals(pc.remoteDescription, offer);
          assert_session_desc_equals(pc.currentRemoteDescription, answer);
          assert_session_desc_equals(pc.pendingRemoteDescription, offer);
        })));
  }, 'Switching role from offerer to answerer after going back to stable state should succeed');

  promise_test(t => {
    const pc = new RTCPeerConnection();
    test_state_change_event(t, 'pc', pc,
      ['have-remote-offer', 'stable', 'have-local-offer']);

    return generateOffer({ data: true })
    .then(offer => pc.setRemoteDescription(offer))
    .then(() => pc.createAnswer())
    .then(answer =>
      pc.setLocalDescription(answer)
      .then(() => pc.createOffer({ offerToReceiveVideo: true }))
      .then(offer =>
        pc.setLocalDescription(offer)
        .then(() => {
          assert_equals(pc.signalingState, 'have-local-offer');
          assert_session_desc_equals(pc.localDescription, offer);
          assert_session_desc_equals(pc.currentLocalDescription, answer);
          assert_session_desc_equals(pc.pendingLocalDescription, offer);
        })));

  }, 'Switching role from answerer to offerer after going back to stable state should succeed');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    return generateOffer()
    .then(offer =>
      promise_rejects(t, 'InvalidStateError',
        pc.setRemoteDescription({ type: 'answer', sdp: offer.sdp })));
  }, 'Calling setRemoteDescription(answer) from stable state should reject with InvalidStateError');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    return generateOffer()
    .then(offer =>
      promise_rejects(t, 'InvalidStateError',
        pc.setLocalDescription({ type: 'answer', sdp: offer.sdp })));

  }, 'Calling setLocalDescription(answer) from stable state should reject with InvalidStateError');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    return pc.createOffer()
    .then(offer => pc.setLocalDescription(offer))
    .then(() => generateOffer())
    .then(offer =>
      promise_rejects(t, 'InvalidStateError',
        pc.setRemoteDescription(offer)));
  }, 'Calling setRemoteDescription(offer) from have-local-offer state should reject with InvalidStateError');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    return pc.createOffer()
    .then(offer =>
      pc.setLocalDescription(offer)
      .then(() => generateAnswer(offer)))
    .then(answer =>
      promise_rejects(t, 'InvalidStateError',
        pc.setLocalDescription(answer)));
  }, 'Calling setLocalDescription(answer) from have-local-offer state should reject with InvalidStateError');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    return generateOffer()
    .then(offer =>
      pc.setRemoteDescription(offer)
      .then(() => generateAnswer(offer)))
    .then(answer =>
      promise_rejects(t, 'InvalidStateError',
        pc.setRemoteDescription(answer)));

  }, 'Calling setRemoteDescription(answer) from have-remote-offer state should reject with InvalidStateError');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    return pc.createOffer({ offerToReceiveAudio: true })
    .then(offer1 => {
      assert_equals(countAudioLine(offer1.sdp), 1,
        'Expect created offer to have audio line');

      // The first createOffer implicitly calls addTransceiver('audio'),
      // so all following offers will also have audio media section
      // in their SDP.
      return pc.createOffer({ offerToReceiveAudio: false })
      .then(offer2 => {
        assert_equals(countAudioLine(offer2.sdp), 1,
          'Expect audio line to remain in created offer');
      })
    });
  }, 'createOffer() with offerToReceiveAudio should add audio line to all subsequent created offers');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    return pc.createOffer({ offerToReceiveVideo: true })
    .then(offer1 => {
      assert_equals(countVideoLine(offer1.sdp), 1,
      'Expect created offer to have video line');

      return pc.createOffer({ offerToReceiveVideo: false })
      .then(offer2 => {
        assert_equals(countVideoLine(offer2.sdp), 1,
          'Expect video line to remain in created offer');
      })
    });
  }, 'createOffer() with offerToReceiveVideo should add video line to all subsequent created offers');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    return pc.createOffer({
      offerToReceiveAudio: true,
      offerToReceiveVideo: false
    }).then(offer1 => {
      assert_equals(countAudioLine(offer1.sdp), 1,
        'Expect audio line to be found in created offer');

      assert_equals(countVideoLine(offer1.sdp), 0,
        'Expect video line to not found in create offer');

      return pc.createOffer({
        offerToReceiveAudio: false,
        offerToReceiveVideo: true
      }).then(offer2 => {
        assert_equals(countAudioLine(offer2.sdp), 1,
          'Expect audio line to remain in created offer');

        assert_equals(countVideoLine(offer2.sdp), 1,
          'Expect video line to be found in create offer');
      })
    });
  }, 'createOffer() with offerToReceiveAudio:true then offerToReceiveVideo:true should have result offer with both audio and video line');

  // TODO: Add tests for rollback, provisional offer/answer, etc

</script>
