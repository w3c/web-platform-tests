<!doctype html>
<meta charset=utf-8>
<title>RTCPeerConnection Set Description tests</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script>
  'use strict';

  // Test is based on the following editor draft:
  // https://w3c.github.io/webrtc-pc/archives/20170515/webrtc.html

  /* Helper Methods */

  const audioLineRegex = /\r\nm=audio.+\r\n/g;
  const videoLineRegex = /\r\nm=video.+\r\n/g;
  const applicationLineRegex = /\r\nm=application.+\r\n/g;

  function countLine(sdp, regex) {
    const matches = sdp.match(regex);
    if(matches === null) {
      return 0;
    } else {
      return matches.length;
    }
  }

  function countAudioLine(sdp) {
    return countLine(sdp, audioLineRegex);
  }

  function countVideoLine(sdp) {
    return countLine(sdp, videoLineRegex);
  }

  function countApplicationLine(sdp) {
    return countLine(sdp, applicationLineRegex);
  }

  function similarMediaDescriptions(sdp1, sdp2) {
    if(sdp1 === sdp2) {
      return true;
    } else if(
      countAudioLine(sdp1) !== countAudioLine(sdp2) ||
      countVideoLine(sdp1) !== countVideoLine(sdp2) ||
      countApplicationLine(sdp1) !== countApplicationLine(sdp2))
    {
      return false;
    } else {
      return true;
    }
  }

  // Assert that given object is either an
  // RTCSessionDescription or RTCSessionDescriptionInit
  function assert_is_session_description(sessionDesc) {
    if(sessionDesc instanceof RTCSessionDescription) {
      return;
    }

    assert_not_equals(sessionDesc, undefined,
      'Expect session description to be defined, but got undefined');

    assert_true(typeof(sessionDesc) === 'object',
      'Expect sessionDescription to be either a RTCSessionDescription or an object');

    assert_true(typeof(sessionDesc.type) === 'string',
      'Expect sessionDescription.type to be a string');

    assert_true(typeof(sessionDesc.type) === 'string',
      'Expect sessionDescription.sdp to be a string');
  }


  // We can't do string comparison to the SDP content,
  // because RTCPeerConnection may return SDP that is
  // slightly modified or reordered from what is given
  // to it due to ICE candidate events or serialization.
  // Instead, we create SDP with different number of media
  // lines, and if the SDP strings are not the same, we
  // simply count the media description lines and if they
  // are the same, we assume it is the same.
  function isSimilarSessionDescription(sessionDesc1, sessionDesc2) {
    assert_is_session_description(sessionDesc1);
    assert_is_session_description(sessionDesc2);

    if(sessionDesc1.type !== sessionDesc2.type) {
      return false;
    } else {
      return similarMediaDescriptions(sessionDesc1.sdp, sessionDesc2.sdp);
    }
  }

  function assert_session_desc_equals(sessionDesc1, sessionDesc2) {
    assert_true(isSimilarSessionDescription(sessionDesc1, sessionDesc2),
      'Expect both session descriptions to have the same count of media lines');
  }

  function assert_session_desc_not_equals(sessionDesc1, sessionDesc2) {
    assert_false(isSimilarSessionDescription(sessionDesc1, sessionDesc2),
      'Expect both session descriptions to have different count of media lines');
  }

  // Helper function to generate offer using a freshly created RTCPeerConnection
  // object with any audio, video, data media lines present
  function generateOffer(options={}) {
    const {
      audio=false,
      video=false,
      data=false
    } = options;

    const pc = new RTCPeerConnection();

    if(data) {
      pc.createDataChannel('test');
    }

    return pc.createOffer({
      offerToReceiveAudio: audio,
      offerToReceiveVideo: video
    }).then(offer => {
      // Guard here to ensure that the generated offer really
      // contain the number of media lines we want
      const { sdp } = offer;

      if(audio) {
        assert_equals(countAudioLine(sdp), 1,
          'Expect m=audio line to be present in generated SDP');
      } else {
        assert_equals(countAudioLine(sdp), 0,
          'Expect m=audio line to be present in generated SDP');
      }

      if(video) {
        assert_equals(countVideoLine(sdp), 1,
          'Expect m=video line to be present in generated SDP');
      } else {
        assert_equals(countVideoLine(sdp), 0,
          'Expect m=video line to not present in generated SDP');
      }

      if(data) {
        assert_equals(countApplicationLine(sdp), 1,
          'Expect m=application line to be present in generated SDP');
      } else {
        assert_equals(countApplicationLine(sdp), 0,
          'Expect m=application line to not present in generated SDP');
      }

      return offer;
    });
  }

  // Helper function to generate answer based on given offer using a freshly
  // created RTCPeerConnection object
  function generateAnswer(offer) {
    const pc = new RTCPeerConnection();
    return pc.setRemoteDescription(offer)
    .then(() => pc.createAnswer());
  }

  // Wait for peer connection to fire onsignalingstatechange
  // event, compare and make sure the new state is the same
  // as expected state. It accepts an RTCPeerConnection object
  // and an array of expected state changes. The test passes
  // if all expected state change events have been fired, and
  // fail if the new state is different from the expected state.
  //
  // Note that the promise is never resolved if no change
  // event is fired. To avoid confusion with the main test
  // getting timed out, this is done in parallel as a separate
  // test
  function test_state_change_event(parentTest, pc, expectedStates) {
    return async_test(t => {
      pc.onsignalingstatechange = t.step_func(() => {
        if(expectedStates.length === 0) {
          return;
        }

        const newState = pc.signalingState;
        const expectedState = expectedStates.shift();

        assert_equals(newState, expectedState, 'New signaling state is different from expected.');

        if(expectedStates.length === 0) {
          t.done();
        }
      });
    }, `Test onsignalingstatechange event for ${parentTest.name}`);
  }

  // Run a test function that return a promise that should
  // never be resolved. For lack of better options,
  // we wait for a time out and pass the test if the
  // promise doesn't resolve within that time.
  function test_never_resolve(testFunc, testName) {
    async_test(t => {
      testFunc(t)
      .then(
        t.step_func(result => {
          assert_unreached(`Pending promise should never be resolved. Instead it is fulfilled with: ${result}`);
        }),
        t.step_func(err => {
          assert_unreached(`Pending promise should never be resolved. Instead it is rejected with: ${err}`);
        }));

      t.step_timeout(t.step_func_done(), 100)
    }, testName);
  }

  /*
   *  4.3.2.  createOffer()
   */

  /*
   *  Final steps to create an offer
   *    4.  Let offer be a newly created RTCSessionDescriptionInit dictionary
   *        with its type member initialized to the string "offer" and its sdp member
   *        initialized to sdpString.
   */
  promise_test(t => {
    const pc = new RTCPeerConnection()

    return pc.createOffer()
    .then(offer => {
      assert_equals(typeof offer, 'object',
        'Expect offer to be plain object dictionary RTCSessionDescriptionInit');

      assert_false(offer instanceof RTCSessionDescription,
        'Expect offer to not be instance of RTCSessionDescription')
    });
  }, 'createOffer() with no argument from newly created RTCPeerConnection should succeed');

  promise_test(t => {
    const pc = new RTCPeerConnection();
    test_state_change_event(t, pc, ['have-local-offer']);

    return pc.createOffer({ offerToReceiveAudio: true })
    .then(offer =>
      pc.setLocalDescription(offer)
      .then(offer => {
        assert_equals(pc.signalingState, 'have-local-offer');
        assert_session_desc_equals(pc.localDescription, offer);
        assert_session_desc_equals(pc.pendingLocalDescription, offer);
        assert_equals(pc.currentLocalDescription, null);
      }));
  }, 'createOffer() and then setLocalDescription() should succeed');

  promise_test(t => {
    const pc = new RTCPeerConnection();
    pc.close();

    return promise_rejects(t, 'InvalidStateError',
      pc.createOffer());
  }, 'createOffer() after connection is closed should reject with InvalidStateError');

  test_never_resolve(t => {
    const pc = new RTCPeerConnection();
    const promise = pc.createOffer();

    pc.close();
    return promise;

  }, 'createOffer() when connection is closed halfway should never resolve');

  /*
   *  4.3.2 createOffer
   *    Final steps to create an offer
   *    2.  If connection was modified in such a way that additional inspection of the
   *        system state is necessary, then in parallel begin the steps to create an
   *        offer again, given p, and abort these steps.
   *
   *  This test might hit step 2 of final steps to create an offer. But the media stream
   *  is likely added already by the time steps to create an offer is executed, because
   *  that is enqueued as an operation.
   *  Either way it verifies that the media stream is included in the offer even though
   *  the stream is added after synchronous call to createOffer.
   */
  promise_test(t => {
    const pc = new RTCPeerConnection();
    const promise = pc.createOffer();

    pc.addTransceiver('audio');
    return promise.then(offer => {
      assert_equals(countAudioLine(offer.sdp), 1,
        'Expect m=audio line to be found in offer SDP')
    });
  }, 'When media stream is added when createOffer() is running in parallel, the result offer should contain the new media stream');

  /*
   *  TODO
   *  4.3.2 createOffer
   *    3.  If connection is configured with an identity provider, and an identity
   *        assertion has not yet been generated using said identity provider, then
   *        begin the identity assertion request process if it has not already begun.
   *    Steps to create an offer
   *    1.  If the need for an identity assertion was identified when createOffer was
   *        invoked, wait for the identity assertion request process to complete.
   *
   *  Non-Testable
   *  4.3.2 createOffer
   *    Steps to create an offer
   *    4.  Inspect the system state to determine the currently available resources as
   *    necessary for generating the offer, as described in [JSEP] (section 4.1.6.).
   *    5.  If this inspection failed for any reason, reject p with a newly created
   *        OperationError and abort these steps.
   */

  /*
   * 4.3.2. setLocalDescription(offer)
   */

  /*
   *  5.  If description.sdp is null and description.type is offer, set description.sdp
   *      to lastOffer.
   */
  promise_test(t => {
    const pc = new RTCPeerConnection();
    return pc.createOffer()
    .then(offer =>
      pc.setLocalDescription({ type: 'offer' })
      .then(() => {
        assert_equals(pc.signalingState, 'have-local-offer');
        assert_session_desc_equals(pc.localDescription, offer);
        assert_session_desc_equals(pc.pendingLocalDescription, offer);
        assert_equals(pc.currentLocalDescription, null);
      }));
  }, 'setLocalDescription with type offer and null sdp should use lastOffer generated from createOffer');

  /*
   *  6.  If description.type is offer and description.sdp does not match lastOffer,
   *      reject the promise with a newly created InvalidModificationError and abort
   *      these steps.
   */
  promise_test(t => {
    const pc = new RTCPeerConnection();

    return generateOffer({ data: true })
    .then(offer =>
      promise_rejects(t, 'InvalidModificationError',
        pc.setLocalDescription(offer)));
  }, 'setLocalDescription() with offer not created by own createOffer() should reject with InvalidModificationError');

  /*
   *  6.  If description.type is offer and description.sdp does not match lastOffer,
   *      reject the promise with a newly created InvalidModificationError and abort
   *      these steps.
   */
  promise_test(t => {
    // Create first offer with audio line, then second offer with
    // both audio and video line. Since the second offer is the
    // last offer, setLocalDescription would reject when setting
    // with the first offer
    const pc = new RTCPeerConnection();
    return pc.createOffer({ offerToReceiveAudio: true })
    .then(offer1 =>
      pc.createOffer({ offerToReceiveVideo: true })
      .then(offer2 => {
        assert_session_desc_not_equals(offer1, offer2);
        return promise_rejects(t, 'InvalidModificationError',
          pc.setLocalDescription(offer1));
      }));
  }, 'Set created offer other than last offer should reject with InvalidModificationError');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    // Only one state change event should be fired
    test_state_change_event(t, pc, ['have-local-offer']);

    return pc.createOffer({ offerToReceiveAudio: true })
    .then(offer1 =>
      pc.setLocalDescription(offer1)
      .then(() =>
        pc.createOffer({ offerToReceiveVideo: true })
        .then(offer2 =>
          pc.setLocalDescription(offer2)
          .then(offer2 => {
            assert_session_desc_not_equals(offer1, offer2);
            assert_equals(pc.signalingState, 'have-local-offer');
            assert_session_desc_equals(pc.localDescription, offer2);
            assert_session_desc_equals(pc.pendingLocalDescription, offer2);
            assert_equals(pc.currentLocalDescription, null);
          }))));
  }, 'Creating and setting offer multiple times should succeed');

  test_never_resolve(t => {
    const pc = new RTCPeerConnection();

    return pc.createOffer()
    .then(offer => {
      const promise = pc.setLocalDescription(offer);
      pc.close();
      return promise;
    });
  }, 'setLocalDescription(offer) should never resolve if connection is closed in parallel')

  /*
   *  TODO
   *  4.3.1.  Setting an RTCSessionDescription
   *    2.2.2.  If description is set as a local description, then run one of
   *            the following steps:
   *      - If description is of type "rollback", then this is a rollback. Set
   *        connection.pendingLocalDescription to null and signaling state to stable.
   *      - If description is of type "pranswer", then set connection.pendingLocalDescription
   *        to description and signaling state to have-local-pranswer.
   */

  /*
   *  4.3.2.  setRemoteDescription(offer)
   */

  promise_test(t => {
    const pc = new RTCPeerConnection();

    test_state_change_event(t, pc, ['have-remote-offer']);

    return generateOffer({ data: true })
    .then(offer =>
      pc.setRemoteDescription(offer)
      .then(offer => {
        assert_equals(pc.signalingState, 'have-remote-offer');
        assert_session_desc_equals(pc.remoteDescription, offer);
        assert_session_desc_equals(pc.pendingRemoteDescription, offer);
        assert_equals(pc.currentRemoteDescription, null);
      }));
  }, 'setRemoteDescription with valid offer should succeed');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    // have-remote-offer event should only fire once
    test_state_change_event(t, pc, ['have-remote-offer']);

    return Promise.all([
      generateOffer({ audio: true }),
      generateOffer({ data: true })
    ]).then(([offer1, offer2]) =>
      pc.setRemoteDescription(offer1)
      .then(() => pc.setRemoteDescription(offer2))
      .then(() => {
        assert_equals(pc.signalingState, 'have-remote-offer');
        assert_session_desc_equals(pc.remoteDescription, offer2);
        assert_session_desc_equals(pc.pendingRemoteDescription, offer2);
        assert_equals(pc.currentRemoteDescription, null);
      }));
  }, 'Setting remote description multiple times with different offer should succeed');

  test_never_resolve(t => {
    const pc = new RTCPeerConnection();

    return generateOffer()
    .then(offer => {
      const promise = pc.setRemoteDescription(offer);
      pc.close();
      return promise;
    });
  }, 'setRemoteDescription(offer) should never resolve if connection is closed in parallel')

  /*
   *  4.3.1.  Setting an RTCSessionDescription
   *    2.4.  If the content of description is not valid SDP syntax, then reject p
   *          with an RTCError (with errorDetail set to "sdp-syntax-error" and the
   *          sdpLineNumber attribute set to the line number in the SDP where the
   *          syntax error was detected) and abort these steps.
   */
  promise_test(t => {
    const pc = new RTCPeerConnection();

    return pc.setRemoteDescription({
      type: 'offer',
      sdp: 'Invalid SDP'
    })
    .then(() => {
      assert_unreached('Expect promise to be rejected');
    }, err => {
      assert_equals(err.errorDetail, 'sdp-syntax-error',
        'Expect error detail field to set to sdp-syntax-error');

      assert_true(err instanceof RTCError,
        'Expect err to be instance of RTCError');
    });

    return promise_rejects(t,
      new RTCError('sdp-syntax-error'),
      );
  }, 'setRemoteDescription(offer) with invalid SDP should reject with RTCError');

  /*
   *  TODO
   *  Setting an RTCSessionDescription
   *    2.1.5. If the content of description is invalid, then reject p with
   *       a newly created InvalidAccessError and abort these steps.
   *    2.2.5-10
   *  setRemoteDescription(rollback)
   *  setRemoteDescription(pranswer)
   *
   *  Non-testable
   *  Setting an RTCSessionDescription
   *    6. For all other errors, for example if description cannot be
   *       applied at the media layer, reject p with a newly created OperationError.
   */

  /*
   * 4.3.2. createAnswer()
   */

  /*
   *  4.1.  If connection's remoteDescription is null return a promise rejected with a
   *        newly created InvalidStateError.
   */
  promise_test(t => {
    const pc = new RTCPeerConnection();
    return promise_rejects(t, 'InvalidStateError',
      pc.createAnswer());
  }, 'createAnswer() with null remoteDescription should reject with InvalidStateError');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    return generateOffer({ video: true })
    .then(offer =>
      pc.setRemoteDescription(offer)
      .then(() => pc.createAnswer(offer)))
    .then(answer => {
      assert_equals(typeof answer, 'object',
        'Expect answer to be plain object dictionary RTCSessionDescriptionInit');

      assert_false(answer instanceof RTCSessionDescription,
        'Expect answer to not be instance of RTCSessionDescription')
    });
  }, 'createAnswer() after setting remote description should succeed');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    return generateOffer({ data: true })
    .then(offer => pc.setRemoteDescription(offer))
    .then(() => {
      pc.close();
      return promise_rejects(t, 'InvalidStateError',
        pc.createAnswer());
    });
  }, 'createAnswer() when connection is closed reject with InvalidStateError');

  test_never_resolve(t => {
    const pc = new RTCPeerConnection();

    return generateOffer({ data: true })
    .then(offer => pc.setRemoteDescription(offer))
    .then(() => {
      const promise = pc.createAnswer();
      pc.close();
      return promise;
    });
  }, 'createAnswer() when connection is closed in parallel should never resolve');

  /*
   *  TODO
   *  4.3.2 createAnswer
   *    3.  If connection is configured with an identity provider, and an
   *        identity assertion has not yet been generated using said
   *        identity provider, then begin the identity assertion request
   *        process if it has not already begun.
   *
   *    Steps to create an answer
   *      1.  If the need for an identity assertion was identified when
   *          createAnswer was invoked, wait for the identity assertion
   *          request process to complete.
   *      2.  If the identity provider was unable to produce an identity
   *          assertion, reject p with a newly created NotReadableError
   *          and abort these steps.
   *      3.  If connection was not constructed with a set of certificates,
   *          and one has not yet been generated, wait for it to be generated.
   *
   *    Final steps to create an answer
   *      2.  If connection was modified in such a way that additional
   *          inspection of the system state is necessary, then in
   *          parallel begin the steps to create an answer again, given p,
   *          and abort these steps.
   *
   *  Non-Testable
   *  4.3.2 createAnswer
   *      Steps to create an answer
   *        4.  Inspect the system state to determine the currently
   *            available resources as necessary for generating the answer,
   *            as described in [JSEP] (section 4.1.7.).
   *        5.  If this inspection failed for any reason, reject p with a
   *            newly created OperationError and abort these steps.
   *
   *      Final steps to create an answer
   *        3.  Given the information that was obtained from previous inspection
   *            and the current state of connection and its RTCRtpTransceivers,
   *            generate an SDP answer, sdpString, as described in [JSEP] (section 5.3.).
   */

  /* setLocalDescription(answer) */

  promise_test(t => {
    const pc = new RTCPeerConnection();
    test_state_change_event(t, pc, ['have-remote-offer', 'stable']);

    return generateOffer({ video: true })
    .then(offer =>
      pc.setRemoteDescription(offer)
      .then(() => pc.createAnswer(offer))
      .then(answer =>
        pc.setLocalDescription(answer)
        .then(() => {
          assert_equals(pc.signalingState, 'stable');
          assert_session_desc_equals(pc.localDescription, answer);
          assert_session_desc_equals(pc.remoteDescription, offer);

          assert_session_desc_equals(pc.currentLocalDescription, answer);
          assert_session_desc_equals(pc.currentRemoteDescription, offer);

          assert_equals(pc.pendingLocalDescription, null);
          assert_equals(pc.pendingRemoteDescription, null);
        })));
  }, 'setLocalDescription() with valid answer should succeed');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    return generateOffer({ video: true })
    .then(offer =>
      pc.setRemoteDescription(offer)
      .then(() => pc.createAnswer(offer))
      .then(answer =>
        pc.setLocalDescription({ type: 'answer' })
        .then(() => {
          assert_equals(pc.signalingState, 'stable');
          assert_session_desc_equals(pc.localDescription, answer);
          assert_session_desc_equals(pc.remoteDescription, offer);

          assert_session_desc_equals(pc.currentLocalDescription, answer);
          assert_session_desc_equals(pc.currentRemoteDescription, offer);

          assert_equals(pc.pendingLocalDescription, null);
          assert_equals(pc.pendingRemoteDescription, null);
        })));
  }, 'setLocalDescription() with type answer and null sdp should use lastAnswer generated from createAnswer');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    return generateOffer({ video: true })
    .then(offer =>
      pc.setRemoteDescription(offer)
      .then(() => generateAnswer(offer))
      .then(answer =>
        promise_rejects(t, 'InvalidModificationError',
          pc.setLocalDescription(answer))));
  }, 'setLocalDescription() with answer not created by own createAnswer() should reject with InvalidModificationError');

  /*
   *  4.3.2.  setRemoteDescription(answer)
   */

  promise_test(t => {
    const pc = new RTCPeerConnection();
    test_state_change_event(t, pc, ['have-local-offer', 'stable']);

    return pc.createOffer({ offerToReceiveVideo: true })
    .then(offer =>
      pc.setLocalDescription(offer)
      .then(() => generateAnswer(offer))
      .then(answer =>
        pc.setRemoteDescription(answer)
        .then(() => {
          assert_session_desc_equals(pc.localDescription, offer);
          assert_session_desc_equals(pc.remoteDescription, answer);

          assert_session_desc_equals(pc.currentLocalDescription, offer);
          assert_session_desc_equals(pc.currentRemoteDescription, answer);

          assert_equals(pc.pendingLocalDescription, null);
          assert_equals(pc.pendingRemoteDescription, null);
        })));
  }, 'setRemoteDescription() with valid state and answer should succeed');

  /*
   *  TODO
   *  4.3.2 setRemoteDescription
   *    If an a=identity attribute is present in the session description,
   *    the browser validates the identity assertion.
   *
   *    If the "peerIdentity" configuration is applied to the RTCPeerConnection,
   *    this establishes a target peer identity of the provided value. Alternatively,
   *    if the RTCPeerConnection has previously authenticated the identity of the
   *    peer (that is, there is a current value for peerIdentity ), then this also
   *    establishes a target peer identity.
   *
   *    The target peer identity cannot be changed once set. Once set,
   *    if a different value is provided, the user agent must reject
   *    the returned promise with a newly created InvalidModificationError
   *    and abort this operation. The RTCPeerConnection must be closed if
   *    the validated peer identity does not match the target peer identity.
   */

  /*
   *  Operations after returning to stable state
   */

  promise_test(t => {
    const pc = new RTCPeerConnection();
    test_state_change_event(t, pc, ['have-local-offer', 'stable', 'have-local-offer']);

    return pc.createOffer({ offerToReceiveAudio: true })
    .then(offer1 =>
      pc.setLocalDescription(offer1)
      .then(() => generateAnswer(offer1))
      .then(answer => pc.setRemoteDescription(answer))
      .then(() => {
        pc.createDataChannel('test');
        return pc.createOffer({ offerToReceiveVideo: true });
      })
      .then(offer2 =>
        pc.setLocalDescription(offer2)
        .then(() => {
          assert_equals(pc.signalingState, 'have-local-offer');
          assert_session_desc_not_equals(offer1, offer2);
          assert_session_desc_equals(pc.localDescription, offer2);
          assert_session_desc_equals(pc.currentLocalDescription, offer1);
          assert_session_desc_equals(pc.pendingLocalDescription, offer2);
        })));
  }, 'Calling createOffer() and setLocalDescription() again after one round of local-offer/remote-answer should succeed');

  promise_test(t => {
    const pc = new RTCPeerConnection();
    const pc2 = new RTCPeerConnection();

    test_state_change_event(t, pc,
      ['have-remote-offer', 'stable', 'have-remote-offer']);

    return generateOffer({ audio: true })
    .then(offer1 =>
      pc.setRemoteDescription(offer1)
      .then(() => pc.createAnswer())
      .then(answer => pc.setLocalDescription(answer))
      .then(() => generateOffer({ data: true }))
      .then(offer2 =>
        pc.setRemoteDescription(offer2)
        .then(() => {
          assert_equals(pc.signalingState, 'have-remote-offer');
          assert_session_desc_not_equals(offer1, offer2);
          assert_session_desc_equals(pc.remoteDescription, offer2);
          assert_session_desc_equals(pc.currentRemoteDescription, offer1);
          assert_session_desc_equals(pc.pendingRemoteDescription, offer2);
        })));
  }, 'Calling setRemoteDescription() again after one round of remote-offer/local-answer should succeed');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    test_state_change_event(t, pc,
       ['have-local-offer', 'stable', 'have-remote-offer']);

    return pc.createOffer({ offerToReceiveAudio: true })
    .then(offer =>
      pc.setLocalDescription(offer)
      .then(() => generateAnswer(offer)))
    .then(answer =>
      pc.setRemoteDescription(answer)
      .then(() => generateOffer({ data: true }))
      .then(offer =>
        pc.setRemoteDescription(offer)
        .then(() => {
          assert_equals(pc.signalingState, 'have-remote-offer');
          assert_session_desc_equals(pc.remoteDescription, offer);
          assert_session_desc_equals(pc.currentRemoteDescription, answer);
          assert_session_desc_equals(pc.pendingRemoteDescription, offer);
        })));
  }, 'Switching role from offerer to answerer after going back to stable state should succeed');

  promise_test(t => {
    const pc = new RTCPeerConnection();
    test_state_change_event(t, pc,
      ['have-remote-offer', 'stable', 'have-local-offer']);

    return generateOffer({ data: true })
    .then(offer => pc.setRemoteDescription(offer))
    .then(() => pc.createAnswer())
    .then(answer =>
      pc.setLocalDescription(answer)
      .then(() => pc.createOffer({ offerToReceiveVideo: true }))
      .then(offer =>
        pc.setLocalDescription(offer)
        .then(() => {
          assert_equals(pc.signalingState, 'have-local-offer');
          assert_session_desc_equals(pc.localDescription, offer);
          assert_session_desc_equals(pc.currentLocalDescription, answer);
          assert_session_desc_equals(pc.pendingLocalDescription, offer);
        })));

  }, 'Switching role from answerer to offerer after going back to stable state should succeed');

  /*
   *  InvalidStateError
   *    [webrtc-pc] 4.3.1. Setting the RTCSessionDescription
   *      2.3.  If the description's type is invalid for the current signaling state
   *            of connection, then reject p with a newly created InvalidStateError
   *            and abort these steps.
   */

  /*
   *  [jsep] 5.6. If the type is "pranswer" or "answer", the PeerConnection
   *              state MUST be either "have-local-offer" or "have-remote-pranswer".
   */
  promise_test(t => {
    const pc = new RTCPeerConnection();

    return generateOffer()
    .then(offer =>
      promise_rejects(t, 'InvalidStateError',
        pc.setRemoteDescription({ type: 'answer', sdp: offer.sdp })));
  }, 'Calling setRemoteDescription(answer) from stable state should reject with InvalidStateError');


  /*
   *  [jsep] 5.5. If the type is "pranswer" or "answer", the PeerConnection
   *              state MUST be either "have-remote-offer" or "have-local-pranswer".
   */
  promise_test(t => {
    const pc = new RTCPeerConnection();

    return generateOffer()
    .then(offer =>
      promise_rejects(t, 'InvalidStateError',
        pc.setLocalDescription({ type: 'answer', sdp: offer.sdp })));

  }, 'Calling setLocalDescription(answer) from stable state should reject with InvalidStateError');

  /*
   *  [jsep] 5.6. If the type is "offer", the PeerConnection state
   *              MUST be either "stable" or "have-remote-offer".
   */
  promise_test(t => {
    const pc = new RTCPeerConnection();

    return pc.createOffer()
    .then(offer => pc.setLocalDescription(offer))
    .then(() => generateOffer())
    .then(offer =>
      promise_rejects(t, 'InvalidStateError',
        pc.setRemoteDescription(offer)));
  }, 'Calling setRemoteDescription(offer) from have-local-offer state should reject with InvalidStateError');

  /*
   *  [jsep] 5.5. If the type is "pranswer" or "answer", the PeerConnection
   *              state MUST be either "have-remote-offer" or "have-local-pranswer".
   */
  promise_test(t => {
    const pc = new RTCPeerConnection();

    return pc.createOffer()
    .then(offer =>
      pc.setLocalDescription(offer)
      .then(() => generateAnswer(offer)))
    .then(answer =>
      promise_rejects(t, 'InvalidStateError',
        pc.setLocalDescription(answer)));
  }, 'Calling setLocalDescription(answer) from have-local-offer state should reject with InvalidStateError');

  /*
   *  [jsep] 5.6. If the type is "pranswer" or "answer", the PeerConnection
   *              state MUST be either "have-local-offer" or "have-remote-pranswer".
   */
  promise_test(t => {
    const pc = new RTCPeerConnection();

    return generateOffer()
    .then(offer =>
      pc.setRemoteDescription(offer)
      .then(() => generateAnswer(offer)))
    .then(answer =>
      promise_rejects(t, 'InvalidStateError',
        pc.setRemoteDescription(answer)));

  }, 'Calling setRemoteDescription(answer) from have-remote-offer state should reject with InvalidStateError');

  /*
   *  4.3.3.2 Configuration data extensions
   *  partial dictionary RTCOfferOptions
   */

  /*
   *  offerToReceiveAudio of type boolean
   *    When this is given a non-false value, no outgoing track of type
   *    "audio" is attached to the PeerConnection, and the existing
   *    localDescription (if any) doesn't contain any sendrecv or recv
   *    audio media sections, createOffer() will behave as if
   *    addTransceiver("audio") had been called once prior to the createOffer() call.
   */
  promise_test(t => {
    const pc = new RTCPeerConnection();

    return pc.createOffer({ offerToReceiveAudio: true })
    .then(offer1 => {
      assert_equals(countAudioLine(offer1.sdp), 1,
        'Expect created offer to have audio line');

      // The first createOffer implicitly calls addTransceiver('audio'),
      // so all following offers will also have audio media section
      // in their SDP.
      return pc.createOffer({ offerToReceiveAudio: false })
      .then(offer2 => {
        assert_equals(countAudioLine(offer2.sdp), 1,
          'Expect audio line to remain in created offer');
      })
    });
  }, 'createOffer() with offerToReceiveAudio should add audio line to all subsequent created offers');

  /*
   *  offerToReceiveVideo of type boolean
   *    When this is given a non-false value, and no outgoing track
   *    of type "video" is attached to the PeerConnection, and the
   *    existing localDescription (if any) doesn't contain any sendecv
   *    or recv video media sections, createOffer() will behave as if
   *    addTransceiver("video") had been called prior to the createOffer() call.
   */
  promise_test(t => {
    const pc = new RTCPeerConnection();

    return pc.createOffer({ offerToReceiveVideo: true })
    .then(offer1 => {
      assert_equals(countVideoLine(offer1.sdp), 1,
      'Expect created offer to have video line');

      return pc.createOffer({ offerToReceiveVideo: false })
      .then(offer2 => {
        assert_equals(countVideoLine(offer2.sdp), 1,
          'Expect video line to remain in created offer');
      })
    });
  }, 'createOffer() with offerToReceiveVideo should add video line to all subsequent created offers');

  promise_test(t => {
    const pc = new RTCPeerConnection();

    return pc.createOffer({
      offerToReceiveAudio: true,
      offerToReceiveVideo: false
    }).then(offer1 => {
      assert_equals(countAudioLine(offer1.sdp), 1,
        'Expect audio line to be found in created offer');

      assert_equals(countVideoLine(offer1.sdp), 0,
        'Expect video line to not found in create offer');

      return pc.createOffer({
        offerToReceiveAudio: false,
        offerToReceiveVideo: true
      }).then(offer2 => {
        assert_equals(countAudioLine(offer2.sdp), 1,
          'Expect audio line to remain in created offer');

        assert_equals(countVideoLine(offer2.sdp), 1,
          'Expect video line to be found in create offer');
      })
    });
  }, 'createOffer() with offerToReceiveAudio:true then offerToReceiveVideo:true should have result offer with both audio and video line');

</script>
