<!doctype html>
<title>RTCPeerConnection Set Description tests</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script type="text/javascript">
  'use strict';

  const audioLineRegex = /\r\nm=audio.+\r\n/g
  const videoLineRegex = /\r\nm=video.+\r\n/g

  function countAudioLine(sdp) {
    const matches = sdp.match(audioLineRegex);
    if(matches === null) {
      return 0;
    } else {
      return matches.length;
    }
  }

  function countVideoLine(sdp) {
    const matches = sdp.match(videoLineRegex);
    if(matches === null) {
      return 0;
    } else {
      return matches.length;
    }
  }

  function similarMediaDescriptions(sdp1, sdp2) {
    if(sdp1 === sdp2) {
      return true;
    } else if(countAudioLine(sdp1) !== countAudioLine(sdp2)) {
      return false;
    } else if(countVideoLine(sdp1) !== countVideoLine(sdp2)) {
      return false;
    } else {
      return true;
    }
  }

  function assert_defined(object) {
    if(object === undefined || object === null)
      assert_unreached('object must not be undefined or null');
  }

  function assert_similar_sdp(sdp1, sdp2) {
    assert_defined(sdp1);
    assert_defined(sdp2);
    assert_equals(sdp1.type, sdp2.type);

    // We can't do string comparison to the SDP content,
    // because RTCPeerConnection may return SDP that is
    // slightly modified from what is given to it due to
    // ice candidate events or serialization.
    // To hack around this, if the SDP strings are not
    // equal, we simply count the media description lines
    // and if they are the same, we assume it is the same.
    assert_true(similarMediaDescriptions(sdp1.sdp, sdp2.sdp));
  }

  function createOfferAndSetLocal(pc, options) {
    return pc.createOffer(options)
    .then(offer => {
      return pc.setLocalDescription(offer)
      .then(() => offer)
    });
  }

  function createOfferAndSetRemote(pc1, pc2, options) {
    return createOfferAndSetLocal(pc1, options)
    .then(offer =>
      pc2.setRemoteDescription(offer)
      .then(() => offer));
  }

  function createOfferAndGetAnswer(pc1, pc2, options) {
    return createOfferAndSetRemote(pc1, pc2, options)
    .then(offer =>
      pc2.createAnswer(offer)
      .then(answer => [offer, answer]))
  }

  function createAnswerAndSetLocal(pc1, pc2, options) {
    return createOfferAndGetAnswer(pc1, pc2, options)
    .then(([offer, answer]) =>
      pc2.setLocalDescription(answer)
      .then(() => [offer, answer]));
  }

  function createAnswerAndSetRemote(pc1, pc2, options) {
    return createAnswerAndSetLocal(pc1, pc2, options)
    .then(([offer, answer]) =>
      pc1.setRemoteDescription(answer)
      .then(() => [offer, answer]));
  }

  test(t => {
    const pc = new RTCPeerConnection;
    assert_equals(pc.signalingState, 'stable');
    assert_equals(pc.localDescription, null);
    assert_equals(pc.currentLocalDescription, null);
    assert_equals(pc.pendingLocalDescription, null);
    assert_equals(pc.remoteDescription, null);
    assert_equals(pc.currentRemoteDescription, null);
    assert_equals(pc.pendingRemoteDescription, null);
  }, 'Initial peer connection state');

  promise_test(t => {
    const pc = new RTCPeerConnection;
    return createOfferAndSetLocal(pc)
    .then(offer => {
      assert_equals(pc.signalingState, 'have-local-offer');
      assert_similar_sdp(pc.localDescription, offer);
      assert_similar_sdp(pc.pendingLocalDescription, offer);
      assert_equals(pc.currentLocalDescription, null);
    });
  }, 'Create and set offer');

  promise_test(t => {
    const pc = new RTCPeerConnection;
    return pc.createOffer()
    .then(offer =>
      pc.setLocalDescription({ type: 'offer' })
      .then(() => {
        assert_equals(pc.signalingState, 'have-local-offer');
        assert_similar_sdp(pc.localDescription, offer);
        assert_similar_sdp(pc.pendingLocalDescription, offer);
        assert_equals(pc.currentLocalDescription, null);
      }));
  }, 'Create and set default offer');

  promise_test(t => {
    const pc = new RTCPeerConnection;
    return pc.createOffer({ offerToReceiveAudio: true })
    .then(offer1 =>
      pc.createOffer({ offerToReceiveVideo: true })
      .then(offer2 => {
        assert_not_equals(offer1.sdp, offer2.sdp);
        return promise_rejects(t, 'InvalidModificationError',
          pc.setLocalDescription(offer1));
      }));
  }, 'Cannot set offer different from last offer');

  promise_test(t => {
    const pc = new RTCPeerConnection;
    return createOfferAndSetLocal(pc, { offerToReceiveAudio: true })
    .then(offer1 =>
       createOfferAndSetLocal(pc, { offerToReceiveVideo: true })
      .then(offer2 => {
        assert_not_equals(offer1.sdp, offer2.sdp);
        assert_equals(pc.signalingState, 'have-local-offer');
        assert_similar_sdp(pc.localDescription, offer2);
        assert_similar_sdp(pc.pendingLocalDescription, offer2);
        assert_equals(pc.currentLocalDescription, null);
      }));
  }, 'Can create and set offer multiple times');

  promise_test(t => {
    const pc1 = new RTCPeerConnection;
    const pc2 = new RTCPeerConnection;

    return createOfferAndSetRemote(pc1, pc2)
    .then(offer => {
      assert_equals(pc2.signalingState, 'have-remote-offer');
      assert_similar_sdp(pc2.remoteDescription, offer);
      assert_similar_sdp(pc2.pendingRemoteDescription, offer);
      assert_equals(pc2.localRemoteDescription, null);
    });
  }, 'Create and set remote offer');

  promise_test(t => {
    const pc1 = new RTCPeerConnection;
    const pc2 = new RTCPeerConnection;

    return createOfferAndSetRemote(pc1, pc2, { offerToReceiveAudio: true })
    .then(offer1 =>
      createOfferAndSetRemote(pc1, pc2, { offerToReceiveVideo: true })
      .then(offer2 => {
        assert_not_equals(offer1.sdp, offer2.sdp);
        assert_equals(pc2.signalingState, 'have-remote-offer');
        assert_similar_sdp(pc2.remoteDescription, offer2);
        assert_similar_sdp(pc2.pendingRemoteDescription, offer2);
        assert_equals(pc2.currentRemoteDescription, null);
      }));
  }, 'Can set remote description multiple times');

  promise_test(t => {
    const pc = new RTCPeerConnection;
    return promise_rejects(t, 'InvalidStateError',
      pc.createAnswer());

  }, 'Cannot create answer with null remoteDescription');

  promise_test(t => {
    const pc1 = new RTCPeerConnection;
    const pc2 = new RTCPeerConnection;

    return createOfferAndGetAnswer(pc1, pc2)
    .then(([offer, answer]) => {
      assert_equals(answer.type, 'answer');
      const sdp = answer.sdp;
      assert_true(typeof(sdp) === 'string');
      assert_greater_than(sdp.length, 0);
    });
  }, 'Can create answer after setting remote description');

  promise_test(t => {
    const pc1 = new RTCPeerConnection;
    const pc2 = new RTCPeerConnection;

    return createAnswerAndSetLocal(pc1, pc2)
    .then(([offer, answer]) => {
      assert_equals(pc2.signalingState, 'stable');
      assert_similar_sdp(pc2.localDescription, answer);
      assert_similar_sdp(pc2.remoteDescription, offer);

      assert_similar_sdp(pc2.currentLocalDescription, answer);
      assert_similar_sdp(pc2.currentRemoteDescription, offer);

      assert_equals(pc2.pendingLocalDescription, null);
      assert_equals(pc2.pendingRemoteDescription, null);
    });
  }, 'Create and set local answer');

  promise_test(t => {
    const pc1 = new RTCPeerConnection;
    const pc2 = new RTCPeerConnection;

    return createAnswerAndSetRemote(pc1, pc2)
    .then(([offer, answer]) => {
      assert_equals(pc1.signalingState, 'stable');
      assert_similar_sdp(pc1.localDescription, offer);
      assert_similar_sdp(pc1.remoteDescription, answer);

      assert_similar_sdp(pc1.currentLocalDescription, offer);
      assert_similar_sdp(pc1.currentRemoteDescription, answer);

      assert_equals(pc1.pendingLocalDescription, null);
      assert_equals(pc1.pendingRemoteDescription, null);
    });
  }, 'Create and set remote answer');

  promise_test(t => {
    const pc = new RTCPeerConnection;

    return pc.createOffer()
    .then(offer =>
      promise_rejects(t, 'InvalidStateError',
        pc.setRemoteDescription({ type: 'answer', sdp: offer.sdp })));
  }, 'Cannot set remote answer from stable state');

  promise_test(t => {
    const pc = new RTCPeerConnection;

    return pc.createOffer()
    .then(offer =>
      promise_rejects(t, 'InvalidStateError',
        pc.setLocalDescription({ type: 'answer', sdp: offer.sdp })));

  }, 'Cannot set local answer from stable state');

  promise_test(t => {
    const pc = new RTCPeerConnection;

    return createOfferAndSetLocal(pc)
    .then(offer =>
      promise_rejects(t, 'InvalidStateError',
        pc.setRemoteDescription(offer)));
  }, 'Cannot set remote offer from have-local-offer state');

  promise_test(t => {
    const pc = new RTCPeerConnection;

    return createOfferAndSetLocal(pc)
    .then(offer =>
      promise_rejects(t, 'InvalidStateError',
        pc.setLocalDescription({ type: 'answer', sdp: offer.sdp })));
  }, 'Cannot set local answer from have-local-offer state');

  promise_test(t => {
    const pc1 = new RTCPeerConnection;
    const pc2 = new RTCPeerConnection;

    return createOfferAndSetRemote(pc1, pc2)
    .then(offer =>
      promise_rejects(t, 'InvalidStateError',
        pc2.setRemoteDescription({ type: 'answer', sdp: offer.sdp })));
  }, 'Cannot set remote answer from have-remote-offer state');

  promise_test(t => {
    const pc = new RTCPeerConnection;

    return pc.createOffer({ offerToReceiveAudio: true })
    .then(offer1 => {
      assert_greater_than(countAudioLine(offer1.sdp), 0);

      // The first createOffer implicitly calls addTransceiver('audio'),
      // so all following offers will also have audio media section
      // in their SDP.
      return pc.createOffer({ offerToReceiveAudio: false })
      .then(offer2 => {
        assert_greater_than(countAudioLine(offer2.sdp), 0);
      })
    });
  }, 'Create with offer to receive audio');

  promise_test(t => {
    const pc = new RTCPeerConnection;

    return pc.createOffer({ offerToReceiveVideo: true })
    .then(offer1 => {
      assert_greater_than(countVideoLine(offer1.sdp), 0);

      return pc.createOffer({ offerToReceiveVideo: false })
      .then(offer2 => {
        assert_greater_than(countVideoLine(offer2.sdp), 0);
      })
    });
  }, 'Create with offer to receive video');

  promise_test(t => {
    const pc = new RTCPeerConnection;

    return pc.createOffer({
      offerToReceiveAudio: true,
      offerToReceiveVideo: false
    }).then(offer1 => {
      assert_greater_than(countAudioLine(offer1.sdp), 0);

      return pc.createOffer({
        offerToReceiveAudio: false,
        offerToReceiveVideo: true
      }).then(offer2 => {
        assert_greater_than(countAudioLine(offer2.sdp), 0);
        assert_greater_than(countVideoLine(offer2.sdp), 0);
      })
    });
  }, 'Create with offer to receive audio then video');

  // TODO: Add tests for rollback, provisional offer/answer, etc

</script>
